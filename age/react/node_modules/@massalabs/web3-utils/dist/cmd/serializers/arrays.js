"use strict";
/* eslint-disable no-case-declarations */
Object.defineProperty(exports, "__esModule", { value: true });
exports.bytesToArray = exports.arrayToBytes = exports.bytesToSerializableObjectArray = exports.deserializeObj = exports.serializableObjectsArrayToBytes = exports.getDatatypeSize = void 0;
const arguments_1 = require("../arguments");
const strings_1 = require("./strings");
const bool_1 = require("./bool");
const numbers_1 = require("./numbers");
/**
 * Get the byte size of a typed array unit.
 *
 * @param typedArrayType - The typed array unit to get the size of.
 *
 * @returns The size of the typed array unit.
 */
const getDatatypeSize = (type) => {
    switch (type) {
        case arguments_1.ArrayType.BOOL:
        case arguments_1.ArrayType.U8:
            return 1;
        case arguments_1.ArrayType.F32:
        case arguments_1.ArrayType.I32:
        case arguments_1.ArrayType.U32:
            return 4;
        case arguments_1.ArrayType.F64:
        case arguments_1.ArrayType.I64:
        case arguments_1.ArrayType.U64:
            return 8;
        case arguments_1.ArrayType.U128:
            return 16;
        case arguments_1.ArrayType.U256:
            return 32;
        default:
            throw new Error(`Unsupported type: ${Object.keys(arguments_1.ArrayType)[type]}`);
    }
};
exports.getDatatypeSize = getDatatypeSize;
/**
 * Serializes an array of serializable objects to bytes.
 *
 * @param source - The array of serializable objects to serialize.
 *
 * @returns The serialized array as Uint8Array.
 */
function serializableObjectsArrayToBytes(source) {
    const nbElements = source.length;
    const pointers = new Array(nbElements);
    const sizes = new Array(nbElements);
    let totalLength = 0;
    for (let i = 0; i < nbElements; i++) {
        const bytes = source[i].serialize();
        pointers[i] = bytes;
        sizes[i] = bytes.length;
        totalLength += bytes.length;
    }
    const target = new Uint8Array(totalLength);
    let offset = 0;
    for (let i = 0; i < nbElements; i++) {
        target.set(pointers[i], offset);
        offset += sizes[i];
    }
    return target;
}
exports.serializableObjectsArrayToBytes = serializableObjectsArrayToBytes;
/**
 * Deserializes a bytes array into an array of deserialized objects.
 *
 * @param data - The bytes array to deserialize.
 * @param offset - The offset to start deserializing from.
 * @param Clazz - The class used for deserialization.
 *
 * @returns The deserialized array of objects.
 */
function deserializeObj(data, offset, Clazz) {
    const deserialized = new Clazz().deserialize(data, offset);
    return deserialized;
}
exports.deserializeObj = deserializeObj;
/**
 * Converts a Uint8Array into an array of deserialized type parameters.
 *
 * @param source - The Uint8Array to convert.
 * @param Clazz - The class constructor for deserialization.
 *
 * @returns An array of deserialized objects.
 */
function bytesToSerializableObjectArray(source, Clazz) {
    const array = [];
    let offset = 0;
    while (offset < source.length) {
        let deserializationResult = deserializeObj(source, offset, Clazz);
        offset = deserializationResult.offset;
        array.push(deserializationResult.instance);
    }
    return array;
}
exports.bytesToSerializableObjectArray = bytesToSerializableObjectArray;
/**
 * Convert an array of native types to a Uint8Array.
 *
 * @remarks
 * This function performs a deep copy for native types only.
 * It is inspired by https://github.com/AssemblyScript/assemblyscript/blob/main/std/assembly/array.ts#L69-L81
 *
 * @param source - The array to convert.
 * @param type - The typed array unit type.
 *
 * @returns The converted Uint8Array.
 */
function arrayToBytes(source, type) {
    let args = new arguments_1.Args();
    source.forEach((value) => {
        switch (type) {
            case arguments_1.ArrayType.STRING:
                args.addString(value);
                break;
            case arguments_1.ArrayType.BOOL:
                args.addBool(value);
                break;
            case arguments_1.ArrayType.U8:
                args.addU8(value);
                break;
            case arguments_1.ArrayType.F64:
                args.addF64(value);
                break;
            case arguments_1.ArrayType.F32:
                args.addF32(value);
                break;
            case arguments_1.ArrayType.I32:
                args.addI32(value);
                break;
            case arguments_1.ArrayType.I64:
                args.addI64(value);
                break;
            case arguments_1.ArrayType.U32:
                args.addU32(value);
                break;
            case arguments_1.ArrayType.U64:
                args.addU64(value);
                break;
            case arguments_1.ArrayType.U128:
                args.addU128(value);
                break;
            case arguments_1.ArrayType.U256:
                args.addU256(value);
                break;
            default:
                throw new Error(`Unsupported type: ${type}`);
        }
    });
    return new Uint8Array(args.serialize());
}
exports.arrayToBytes = arrayToBytes;
/**
 * Converts a Uint8Array into an array of native types.
 *
 * @remarks
 * This function is inspired by https://github.com/AssemblyScript/assemblyscript/blob/main/std/assembly/array.ts#L69-L81
 *
 * @param source - The Uint8Array to convert.
 * @param type - The typed array unit type.
 *
 * @returns An array of converted native types.
 */
function bytesToArray(source, type) {
    const sourceLength = source.length;
    let byteOffset = 0;
    const result = [];
    let eltSize;
    if (type !== arguments_1.ArrayType.STRING) {
        eltSize = (0, exports.getDatatypeSize)(type);
    }
    while (byteOffset < sourceLength) {
        if (type === arguments_1.ArrayType.STRING) {
            eltSize = (0, numbers_1.bytesToU32)(source, byteOffset);
            byteOffset += 4;
        }
        const elt = source.slice(byteOffset, byteOffset + eltSize);
        byteOffset += eltSize;
        switch (type) {
            case arguments_1.ArrayType.STRING:
                result.push((0, strings_1.bytesToStr)(elt));
                break;
            case arguments_1.ArrayType.BOOL:
                result.push((0, bool_1.byteToBool)(elt));
                break;
            case arguments_1.ArrayType.U8:
                result.push((0, numbers_1.byteToU8)(elt));
                break;
            case arguments_1.ArrayType.F32:
                result.push((0, numbers_1.bytesToF32)(elt));
                break;
            case arguments_1.ArrayType.F64:
                result.push((0, numbers_1.bytesToF64)(elt));
                break;
            case arguments_1.ArrayType.I32:
                result.push((0, numbers_1.bytesToI32)(elt));
                break;
            case arguments_1.ArrayType.I64:
                result.push((0, numbers_1.bytesToI64)(elt));
                break;
            case arguments_1.ArrayType.U32:
                result.push((0, numbers_1.bytesToU32)(elt));
                break;
            case arguments_1.ArrayType.U64:
                result.push((0, numbers_1.bytesToU64)(elt));
                break;
            case arguments_1.ArrayType.U128:
                result.push((0, numbers_1.bytesToU128)(elt));
                break;
            case arguments_1.ArrayType.U256:
                result.push((0, numbers_1.bytesToU256)(elt));
                break;
        }
    }
    return result;
}
exports.bytesToArray = bytesToArray;
//# sourceMappingURL=arrays.js.map