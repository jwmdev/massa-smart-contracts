import { ISerializable } from './ISerializable';
/**
 * Typed Arguments facilitating the differentiation
 * between different argument types due to Javascript's
 * single number type.
 *
 * @remarks In AssemblyScript the latter are all native types
 */
export declare enum ArrayType {
    STRING = 0,
    BOOL = 1,
    U8 = 2,
    U32 = 3,
    U64 = 4,
    U128 = 5,
    U256 = 6,
    I32 = 7,
    I64 = 8,
    F32 = 9,
    F64 = 10
}
/**
 * Native types in AssemblyScript
 *
 * @remarks
 * These are the types that can be used in AssemblyScript
 */
export type NativeType = string | boolean | number | bigint;
/**
 * Storage and serialization class for remote function call arguments.
 *
 * @remarks
 * This class can serialize typescript native types into bytes, in order to
 * make smart-contract function call easier.
 * It also can deserialize bytes.
 *
 */
export declare class Args {
    private offset;
    private serialized;
    /**
     * Constructor to either serialize or deserialize data passed from/to DApps and remote Smart contracts.
     *
     * @param serialized - The optional serialized arguments to deserialize.
     * @param offset - The optional offset to start deserializing from.
     */
    constructor(serialized?: Array<number> | Uint8Array, offset?: number);
    /**
     * Returns the current deserialization offset of the serialized byte array.
     *
     * @returns the current offset
     */
    getOffset(): number;
    /**
     * Returns the serialized byte array.
     *
     * @returns A byte array.
     */
    serialize(): Array<number>;
    /**
     * Returns the next string in the serialized byte array.
     *
     * @remarks
     * Increments to offset to point the data after the one that as been deserialized in the byte array.
     *
     * @returns the deserialized string
     */
    nextString(): string;
    /**
     * Returns the next unsigned byte in the serialized byte array.
     *
     * @remarks
     * Increments to offset to point the data after the one that as been deserialized in the byte array.
     *
     * @returns the deserialized number.
     */
    nextU8(): bigint;
    /**
     * Returns the next unsigned integer in the serialized byte array.
     *
     * @remarks
     * Increments to offset to point the data after the one that as been deserialized in the byte array.
     *
     * @returns the deserialized number
     */
    nextU32(): number;
    /**
     * Returns the next long integer in the serialized byte array.
     *
     * @remarks
     * Increments to offset to point the data after the one that as been deserialized in the byte array.
     *
     * @returns the deserialized number.
     */
    nextU64(): bigint;
    /**
     * Returns the next uint128 in the serialized byte array.
     *
     * @remarks
     * Increments to offset to point the data after the one that as been deserialized in the byte array.
     *
     * @returns the deserialized number.
     */
    nextU128(): bigint;
    /**
     * Returns the next uint256 in the serialized byte array.
     *
     * @remarks
     * Increments to offset to point the data after the one that as been deserialized in the byte array.
     *
     * @returns the deserialized number.
     */
    nextU256(): bigint;
    /**
     * Returns the next boolean in the serialized byte array.
     *
     * @remarks
     * Increments to offset to point the data after the one that as been deserialized in the byte array.
     *
     * @returns the deserialized boolean.
     */
    nextBool(): boolean;
    /**
     * Returns the next signed integer in the serialized byte array.
     *
     * @remarks
     * Increments to offset to point the data after the one that as been deserialized in the byte array.
     *
     * @returns the deserialized number.
     */
    nextI32(): number;
    /**
     * Returns the next signed long integer in the serialized byte array.
     *
     * @remarks
     * Increments to offset to point the data after the one that as been deserialized in the byte array.
     *
     * @returns the deserialized number.
     */
    nextI64(): bigint;
    /**
     * Returns the next floating number in the serialized byte array.
     *
     * @remarks
     * Increments to offset to point the data after the one that as been deserialized in the byte array.
     *
     * @returns the deserialized number.
     */
    nextF32(): number;
    /**
     * Returns the next long floating number in the serialized byte array.
     *
     * @remarks
     * Increments to offset to point the data after the one that as been deserialized in the byte array.
     *
     * @returns the deserialized number.
     */
    nextF64(): number;
    /**
     * Returns the next sub byte array in the serialized byte array.
     *
     * @remarks
     * Increments to offset to point the data after the one that as been deserialized in the byte array.
     *
     * @returns the deserialized byte array.
     */
    nextUint8Array(): Uint8Array;
    /**
     * Returns the next {@link ISerializable} object in the serialized byte array
     *
     * @remarks
     * Increments to offset to point the data after the one that as been deserialized in the byte array.
     *
     * @param ctor - the class constructor prototype T.prototype
     *
     * @returns the deserialized object T
     */
    nextSerializable<T extends ISerializable<T>>(ctor: new () => T): T;
    /**
     * Returns the next array of {@link ISerializable} objects in the serialized byte array
     *
     * @remarks
     * Increments to offset to point the data after the one that as been deserialized in the byte array.
     *
     * @param ctor - the class constructor prototype T.prototype
     *
     * @returns the deserialized array of object that implement ISerializable
     */
    nextSerializableObjectArray<T extends ISerializable<T>>(ctor: new () => T): T[];
    /**
     * Returns the next array of {@link ArrayType} objects in the serialized byte array
     *
     * @remarks
     * Increments to offset to point the data after the one that as been deserialized in the byte array.
     *
     * @param type - the type of the elements in the array.
     *
     * @returns the next array of object that are native type
     */
    nextArray<T>(type: ArrayType): T[];
    /**
     * Adds a unsigned byte to the serialized arguments.
     *
     * @param value - the number to add.
     *
     * @returns the serialized arguments to be able to chain `add` method calls.
     */
    addU8(value: number): this;
    /**
     * Adds a boolean to the serialized arguments.
     *
     * @param value - the boolean to add.
     *
     * @returns the serialized arguments to be able to chain `add` method calls.
     */
    addBool(value: boolean): this;
    /**
     * Adds an unsigned integer to the serialized arguments.
     *
     * @param value - the number to add.
     *
     * @returns the serialized arguments to be able to chain `add` method calls.
     */
    addU32(value: number): this;
    /**
     * Adds an unsigned long integer to the serialized arguments.
     *
     * @param value - the number to add.
     *
     * @returns the serialized arguments to be able to chain `add` method calls.
     */
    addU64(bigInt: bigint): this;
    /**
     * Adds an unsigned long integer to the serialized arguments.
     *
     * @param value - the number to add.
     *
     * @returns the serialized arguments to be able to chain `add` method calls.
     */
    addU128(bigInt: bigint): this;
    /**
     * Adds an unsigned long integer to the serialized arguments.
     *
     * @param value - the number to add.
     *
     * @returns the serialized arguments to be able to chain `add` method calls.
     */
    addU256(bigInt: bigint): this;
    /**
     * Adds a signed integer to the serialized arguments.
     *
     * @param value - the number to add.
     *
     * @returns the serialized arguments to be able to chain `add` method calls.
     */
    addI32(value: number): this;
    /**
     * Adds a signed long integer to the serialized arguments.
     *
     * @param value - the number to add.
     *
     * @returns the serialized arguments to be able to chain `add` method calls.
     */
    addI64(bigInt: bigint): this;
    /**
     * Adds a floating number to the serialized arguments.
     *
     * @param value - the number to add.
     *
     * @returns the serialized arguments to be able to chain `add` method calls.
     */
    addF32(value: number): this;
    /**
     * Adds a long floating number to the serialized arguments.
     *
     * @param value - the number to add.
     *
     * @returns the serialized arguments to be able to chain `add` method calls.
     */
    addF64(value: number): this;
    /**
     * Adds a byte array integer to the serialized arguments.
     *
     * @param array - the array to add.
     *
     * @returns the serialized arguments to be able to chain `add` method calls.
     */
    addUint8Array(array: Uint8Array): this;
    /**
     * Adds a string to the serialized arguments.
     *
     * @remarks
     * Works only if the argument is an instance of a handled type (String of 4294967295 characters maximum)
     *
     * @param value - the number to add.
     *
     * @returns the serialized arguments to be able to chain `add` method calls.
     */
    addString(arg: string): this;
    /**
     * Adds a serializable object to the serialized arguments.
     *
     * @remarks
     * The object must implement the {@link ISerializable} interface
     *
     * @see {@link ISerializable}
     *
     * @param value - the object to add
     *
     * @returns the serialized arguments to be able to chain `add` method calls.
     */
    addSerializable<T>(value: ISerializable<T>): this;
    /**
     * Adds an array of serializable objects to the serialized arguments.
     *
     * @remarks
     * Each object must implement the {@link ISerializable} interface.
     * This will perform a deep copy of your objects thanks to the {@link ISerializable.serialize}
     * method you define in your class.
     *
     * @see {@link ISerializable}
     *
     * @param arg - the argument to add
     *
     * @returns the serialized arguments to be able to chain `add` method calls.
     */
    addSerializableObjectArray<T extends ISerializable<T>>(arg: T[]): this;
    /**
     * Adds an array of objects to the serialized arguments.
     *
     * @remarks
     * If the type of the values of the array is not native type, this will serialize the pointers, which is certainly
     * not what you want! You can only serialize properly array of native types or array of `Serializable` object.
     *
     * @see {@link addSerializableObjectArray}
     *
     * @param arg - the argument to add
     *
     * @returns the serialized arguments to be able to chain `add` method calls.
     */
    addArray(arg: NativeType[], type: ArrayType): this;
    /**
     * Internal function to concat to Uint8Array.
     *
     * @param a - first array to concat
     * @param b - second array to concat
     *
     * @returns the concatenated array
     */
    static concatArrays(a: Uint8Array, b: Uint8Array): Uint8Array;
    /**
     * Returns the data of requested size for current offset
     *
     * @param size - The data size
     * @returns the slice of the serialized internal buffer
     */
    private getNextData;
}
