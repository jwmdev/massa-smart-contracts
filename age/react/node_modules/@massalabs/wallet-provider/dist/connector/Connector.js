"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.connector = exports.MASSA_WINDOW_OBJECT = void 0;
/**
 * This file defines a TypeScript module named connector.
 * It is the tool that allows the 'provider' and 'account' objects to communicate with the web page script.
 *
 * @remarks
 * - If you are only looking to use our library, the connector object will not be useful to you.
 * - If you want to work on this repo, you will probably be interested in this object
 *
 */
const uid_1 = require("uid");
const __1 = require("..");
const MassaStationDiscovery_1 = require("../massaStation/MassaStationDiscovery");
const MassaStationProvider_1 = require("../massaStation/MassaStationProvider");
/**
 * A constant string that is used to identify the HTML element that is used for
 * communication between the web page script and the content script.
 */
exports.MASSA_WINDOW_OBJECT = 'massaWalletProvider';
/**
 * This class enables communication with the content script by sending and receiving messages.
 * @remarks
 * - This class is used to send messages to the content script and to receive messages from the content script.
 * - It is used to send messages to the content script and to receive messages from the content script.
 *
 */
class Connector {
    /**
     * Connector constructor
     *
     * @remarks
     * - The Connector constructor takes no arguments.
     * - It creates a Map object that is used to store pending requests.
     * - It creates an HTML element that is used to communicate with the content script.
     * - It adds an event listener to the HTML element that is used to communicate with the content script.
     *
     * @returns An instance of the Connector class.
     *
     */
    constructor() {
        this.registeredProviders = {};
        this.pendingRequests = new Map();
        this.register();
        // start listening to messages from content script
        document
            .getElementById(exports.MASSA_WINDOW_OBJECT)
            .addEventListener('message', this.handleResponseFromContentScript.bind(this));
    }
    /**
     * This method adds a register listener in the web page.
     * It listens to the 'register' event.
     *
     * @returns void
     *
     * @remarks
     * - It is used to register a new provider.
     * - This method creates a new HTML element and a listener that listens to the register event.
     *
     */
    register() {
        // global event target to use for all wallet provider
        if (!document.getElementById(exports.MASSA_WINDOW_OBJECT)) {
            const inv = document.createElement('p');
            inv.id = exports.MASSA_WINDOW_OBJECT;
            inv.setAttribute('style', 'display:none');
            document.body.appendChild(inv);
        }
        // add an invisible HTML element and set a listener to it like the following
        // hook up register handler
        document
            .getElementById(exports.MASSA_WINDOW_OBJECT)
            .addEventListener('register', (evt) => {
            const payload = evt.detail;
            const providerEventTargetName = `${exports.MASSA_WINDOW_OBJECT}_${payload.providerName}`;
            this.registeredProviders[payload.providerName] =
                providerEventTargetName;
        });
        try {
            // start MassaStation discovery
            this.massaStationListener = new MassaStationDiscovery_1.MassaStationDiscovery(1000);
            this.massaStationListener.startListening();
            this.massaStationListener.on(MassaStationDiscovery_1.ON_MASSA_STATION_DISCOVERED, () => {
                this.registeredProviders[MassaStationProvider_1.MASSA_STATION_PROVIDER_NAME] = `${exports.MASSA_WINDOW_OBJECT}_${MassaStationProvider_1.MASSA_STATION_PROVIDER_NAME}`;
            });
            this.massaStationListener.on(MassaStationDiscovery_1.ON_MASSA_STATION_DISCONNECTED, () => {
                delete this.registeredProviders[MassaStationProvider_1.MASSA_STATION_PROVIDER_NAME];
            });
        }
        catch (e) {
            console.log('MassaStation is not detected');
        }
    }
    /**
     * This method sends a message from the webpage script to the content script.
     *
     * @remarks
     * Sends a message to the content script using the specified provider name, command, and parameters,
     *
     * @privateRemarks
     * This method registers the response callback with a unique ID.
     *
     * @param providerName - The name of the provider.
     * @param command - The command that is sent to the content script (among the {@link AvailableCommands}).
     * @param params - The parameters that are sent to the content script.
     * @param responseCallback - The callback function that is called when the content script sends a response.
     * @returns void
     *
     */
    sendMessageToContentScript(providerName, command, params, responseCallback) {
        if (!Object.values(__1.AvailableCommands).includes(command)) {
            throw new Error(`Unknown command ${command}`);
        }
        const requestId = (0, uid_1.uid)();
        const eventMessageRequest = {
            params,
            requestId,
        };
        this.pendingRequests.set(requestId, responseCallback);
        // dispatch an event to the specific provider event target
        const specificProviderEventTarget = document.getElementById(`${this.registeredProviders[providerName]}`);
        if (!specificProviderEventTarget) {
            throw new Error(`Registered provider with name ${providerName} does not exist`);
        }
        const isDispatched = specificProviderEventTarget.dispatchEvent(new CustomEvent(command, { detail: eventMessageRequest }));
        if (!isDispatched) {
            throw new Error(`Could not dispatch a message to ${this.registeredProviders[providerName]}`);
        }
    }
    /**
     * This method returns the registered providers.
     *
     * @returns The registered provider associated with its unique key.
     *
     */
    getWalletProviders() {
        return this.registeredProviders;
    }
    /**
     * This method handles the response from the content script by
     * calling the response callback with the response and error objects.
     *
     * @param event - The event that is sent from the content script.
     * @returns void
     *
     */
    handleResponseFromContentScript(event) {
        const { result, error, requestId } = event.detail;
        const responseCallback = this.pendingRequests.get(requestId);
        if (responseCallback) {
            if (error) {
                responseCallback(null, new Error(error.message));
            }
            else {
                responseCallback(result, null);
            }
            const deleted = this.pendingRequests.delete(requestId);
            if (!deleted) {
                console.error(`Error deleting a pending request with id ${requestId}`);
            }
        }
        else {
            console.error(`Request Id ${requestId} not found in response callback map`);
        }
    }
}
exports.connector = new Connector();
