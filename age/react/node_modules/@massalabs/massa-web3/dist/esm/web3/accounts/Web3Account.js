import { base58Encode, hashBlake3, varintEncode } from '../../utils/Xbqcrypto';
import { Address, SecretKey } from '../../utils/keyAndAddresses';
import * as ed from '@noble/ed25519';
import { BaseClient } from '../BaseClient';
import { OperationTypeId } from '../../interfaces/OperationTypes';
import { getBytesPublicKey } from '../../utils/bytes';
import { JSON_RPC_REQUEST_METHOD } from '../../interfaces/JsonRpcMethods';
import { trySafeExecute } from '../../utils/retryExecuteFunction';
export class Web3Account extends BaseClient {
    account;
    publicApiClient;
    constructor(account, publicApiClient) {
        super(publicApiClient.clientConfig);
        this.account = account;
        this.publicApiClient = publicApiClient;
    }
    async verify() {
        // Create the secret key object
        const secretKeyBase58Encoded = this.account.secretKey;
        const secretKey = new SecretKey(secretKeyBase58Encoded);
        // create the public key object
        const publicKey = await secretKey.getPublicKey();
        if (this.account.publicKey &&
            this.account.publicKey !== publicKey.base58Encode) {
            throw new Error('Public key does not correspond the the private key submitted');
        }
        // get wallet account address
        const address = new Address(publicKey);
        if (this.account.address && this.account.address !== address.base58Encode) {
            throw new Error('Account address not correspond the the address submitted');
        }
    }
    async sign(data) {
        // check private keys to sign the message with.
        if (!this.account.secretKey) {
            throw new Error('No private key to sign the message with');
        }
        // check public key to verify the message with.
        if (!this.account.publicKey) {
            throw new Error('No public key to verify the signed message with');
        }
        // get private key
        const secretKey = new SecretKey(this.account.secretKey);
        // bytes compaction
        const bytesCompact = Buffer.from(data);
        // Hash byte compact
        const messageHashDigest = hashBlake3(bytesCompact);
        // sign the digest
        const sig = await secretKey.signDigest(messageHashDigest);
        // check sig length
        if (sig.length != 64) {
            throw new Error(`Invalid signature length. Expected 64, got ${sig.length}`);
        }
        // verify signature
        if (this.account.publicKey) {
            const publicKey = await secretKey.getPublicKey();
            const isVerified = await ed.verify(sig, messageHashDigest, publicKey.bytes);
            if (!isVerified) {
                throw new Error(`Signature could not be verified with public key. Please inspect`);
            }
        }
        // convert signature to base58
        const version = Buffer.from(varintEncode(secretKey.version));
        const base58Encoded = base58Encode(Buffer.concat([version, sig]));
        return {
            base58Encoded,
        };
    }
    address() {
        return this.account.address;
    }
    async sellRolls(txData) {
        if (!this.account) {
            throw new Error(`No tx sender available`);
        }
        // get next period info
        const nodeStatusInfo = await this.publicApiClient.getNodeStatus();
        const expiryPeriod = nodeStatusInfo.next_slot.period + this.clientConfig.periodOffset;
        // bytes compaction
        const bytesCompact = this.compactBytesForOperation(txData, OperationTypeId.RollSell, expiryPeriod);
        // sign payload
        const signature = await this.sign(Buffer.concat([getBytesPublicKey(this.account.publicKey), bytesCompact]));
        const data = {
            serialized_content: Array.prototype.slice.call(bytesCompact),
            creator_public_key: this.account.publicKey,
            signature: signature.base58Encoded,
        };
        // returns operation ids
        const opIds = await this.sendJsonRPCRequest(JSON_RPC_REQUEST_METHOD.SEND_OPERATIONS, [[data]]);
        return opIds[0];
    }
    async buyRolls(txData) {
        // get next period info
        const nodeStatusInfo = await this.publicApiClient.getNodeStatus();
        const expiryPeriod = nodeStatusInfo.next_slot.period + this.clientConfig.periodOffset;
        // bytes compaction
        const bytesCompact = this.compactBytesForOperation(txData, OperationTypeId.RollBuy, expiryPeriod);
        // sign payload
        const signature = await this.sign(Buffer.concat([getBytesPublicKey(this.account.publicKey), bytesCompact]));
        const data = {
            serialized_content: Array.prototype.slice.call(bytesCompact),
            creator_public_key: this.account.publicKey,
            signature: signature.base58Encoded,
        };
        // returns operation ids
        const opIds = await this.sendJsonRPCRequest(JSON_RPC_REQUEST_METHOD.SEND_OPERATIONS, [[data]]);
        return opIds[0];
    }
    async sendTransaction(txData) {
        // get next period info
        const nodeStatusInfo = await this.publicApiClient.getNodeStatus();
        const expiryPeriod = nodeStatusInfo.next_slot.period + this.clientConfig.periodOffset;
        // bytes compaction
        const bytesCompact = this.compactBytesForOperation(txData, OperationTypeId.Transaction, expiryPeriod);
        // sign payload
        const bytesPublicKey = getBytesPublicKey(this.account.publicKey);
        const signature = await this.sign(Buffer.concat([bytesPublicKey, bytesCompact]));
        // prepare tx data
        const data = {
            serialized_content: Array.prototype.slice.call(bytesCompact),
            creator_public_key: this.account.publicKey,
            signature: signature.base58Encoded,
        };
        // returns operation ids
        const opIds = await this.sendJsonRPCRequest(JSON_RPC_REQUEST_METHOD.SEND_OPERATIONS, [[data]]);
        return opIds[0];
    }
    async callSmartContract(callData) {
        // get next period info
        const nodeStatusInfo = await this.publicApiClient.getNodeStatus();
        const expiryPeriod = nodeStatusInfo.next_slot.period + this.clientConfig.periodOffset;
        // bytes compaction
        const bytesCompact = this.compactBytesForOperation(callData, OperationTypeId.CallSC, expiryPeriod);
        // sign payload
        const bytesPublicKey = getBytesPublicKey(this.account.publicKey);
        const signature = await this.sign(Buffer.concat([bytesPublicKey, bytesCompact]));
        // request data
        const data = {
            serialized_content: Array.prototype.slice.call(bytesCompact),
            creator_public_key: this.account.publicKey,
            signature: signature.base58Encoded,
        };
        // returns operation ids
        let opIds = [];
        const jsonRpcRequestMethod = JSON_RPC_REQUEST_METHOD.SEND_OPERATIONS;
        if (this.clientConfig.retryStrategyOn) {
            opIds = await trySafeExecute(this.sendJsonRPCRequest, [
                jsonRpcRequestMethod,
                [[data]],
            ]);
        }
        else {
            opIds = await this.sendJsonRPCRequest(jsonRpcRequestMethod, [[data]]);
        }
        if (opIds.length <= 0) {
            throw new Error(`Call smart contract operation bad response. No results array in json rpc response. Inspect smart contract`);
        }
        return opIds[0];
    }
    async deploySmartContract(contractData) {
        // get next period info
        const nodeStatusInfo = await this.publicApiClient.getNodeStatus();
        const expiryPeriod = nodeStatusInfo.next_slot.period + this.clientConfig.periodOffset;
        // Check if SC data exists
        if (!contractData.contractDataBinary) {
            throw new Error(`Expected non-null contract bytecode, but received null.`);
        }
        // get the block size
        if (contractData.contractDataBinary.length >
            nodeStatusInfo.config.max_block_size / 2) {
            console.warn('bytecode size exceeded half of the maximum size of a block, operation will certainly be rejected');
        }
        // bytes compaction
        const bytesCompact = this.compactBytesForOperation(contractData, OperationTypeId.ExecuteSC, expiryPeriod);
        // sign payload
        const bytesPublicKey = getBytesPublicKey(this.account.publicKey);
        const signature = await this.sign(Buffer.concat([bytesPublicKey, bytesCompact]));
        const data = {
            serialized_content: Array.prototype.slice.call(bytesCompact),
            creator_public_key: this.account.publicKey,
            signature: signature.base58Encoded,
        };
        // returns operation ids
        const opIds = await this.sendJsonRPCRequest(JSON_RPC_REQUEST_METHOD.SEND_OPERATIONS, [[data]]);
        if (opIds.length <= 0) {
            throw new Error(`Deploy smart contract operation bad response. No results array in json rpc response. Inspect smart contract`);
        }
        return opIds[0];
    }
}
//# sourceMappingURL=Web3Account.js.map