"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PublicApiClient = void 0;
const retryExecuteFunction_1 = require("../utils/retryExecuteFunction");
const JsonRpcMethods_1 = require("../interfaces/JsonRpcMethods");
const BaseClient_1 = require("./BaseClient");
/**
 * Public API client for interacting with a Massa node.
 *
 * This class provides an interface for interacting with the public API of a Massa node.
 * It offers methods for querying various data structures used in the Massa blockchain,
 * such as blocks, endorsements, operations, and stakers.
 *
 * @module PublicApiClient
 */
class PublicApiClient extends BaseClient_1.BaseClient {
    /**
     * Constructor for the {@link PublicApiClient} object.
     *
     * @param clientConfig - The configuration settings for this client.
     */
    constructor(clientConfig) {
        super(clientConfig);
        // Bind all public API methods to the current context.
        // This ensures that the methods can be called correctly even when their context is lost.
        // For example, when passed as a callback function.
        // public api methods
        this.getNodeStatus = this.getNodeStatus.bind(this);
        this.getAddresses = this.getAddresses.bind(this);
        this.getBlocks = this.getBlocks.bind(this);
        this.getEndorsements = this.getEndorsements.bind(this);
        this.getOperations = this.getOperations.bind(this);
        this.getCliques = this.getCliques.bind(this);
        this.getStakers = this.getStakers.bind(this);
        this.getBlockcliqueBlockBySlot = this.getBlockcliqueBlockBySlot.bind(this);
        this.getGraphInterval = this.getGraphInterval.bind(this);
    }
    /**
     * Get graph interval.
     *
     * @param graphInterval - The graph interval values in ms as an IGetGraphInterval.
     *
     * @returns A promise which resolves in the graph interval.
     */
    async getGraphInterval(graphInterval) {
        const jsonRpcRequestMethod = JsonRpcMethods_1.JSON_RPC_REQUEST_METHOD.GET_GRAPH_INTERVAL;
        if (this.clientConfig.retryStrategyOn) {
            return await (0, retryExecuteFunction_1.trySafeExecute)(this.sendJsonRPCRequest, [jsonRpcRequestMethod, [graphInterval]]);
        }
        else {
            return await this.sendJsonRPCRequest(jsonRpcRequestMethod, [graphInterval]);
        }
    }
    /**
     * Get blockclique details by period and thread.
     *
     * @param slot - The slot as an ISlot.
     *
     * @returns A promise which resolves in the blockclique details.
     */
    async getBlockcliqueBlockBySlot(slot) {
        const jsonRpcRequestMethod = JsonRpcMethods_1.JSON_RPC_REQUEST_METHOD.GET_BLOCKCLIQUE_BLOCK_BY_SLOT;
        if (this.clientConfig.retryStrategyOn) {
            return await (0, retryExecuteFunction_1.trySafeExecute)(this.sendJsonRPCRequest, [jsonRpcRequestMethod, [slot]]);
        }
        else {
            return await this.sendJsonRPCRequest(jsonRpcRequestMethod, [slot]);
        }
    }
    /**
     * Retrieves the node's status.
     *
     * @remarks
     * The returned information includes:
     * - Whether the node is reachable
     * - The number of connected peers
     * - The node's version
     * - The node's configuration parameters
     *
     * @returns A promise that resolves to the node's status information.
     */
    async getNodeStatus() {
        const jsonRpcRequestMethod = JsonRpcMethods_1.JSON_RPC_REQUEST_METHOD.GET_STATUS;
        if (this.clientConfig.retryStrategyOn) {
            return await (0, retryExecuteFunction_1.trySafeExecute)(this.sendJsonRPCRequest, [
                jsonRpcRequestMethod,
                [],
            ]);
        }
        else {
            return await this.sendJsonRPCRequest(jsonRpcRequestMethod, []);
        }
    }
    /**
     * Retrieves data about a list of addresses, such as their balances and block creation details.
     *
     * @param addresses - An array of addresses to query.
     *
     * @returns A promise that resolves to an array of address information.
     */
    async getAddresses(addresses) {
        const jsonRpcRequestMethod = JsonRpcMethods_1.JSON_RPC_REQUEST_METHOD.GET_ADDRESSES;
        if (this.clientConfig.retryStrategyOn) {
            return await (0, retryExecuteFunction_1.trySafeExecute)(this.sendJsonRPCRequest, [jsonRpcRequestMethod, [addresses]]);
        }
        else {
            return await this.sendJsonRPCRequest(jsonRpcRequestMethod, [addresses]);
        }
    }
    /**
     * Show data about a block (content, finality ...).
     *
     * @remarks
     * The blocks are stored in the node cache. After a certain time (depending of the network activity),
     * the blocks are removed from the cache and the node will not be able to return the block data.
     * The corresponding api parameter is 'max_discarded_blocks'.
     * More information can be found here: https://docs.massa.net/en/latest/testnet/all-config.html
     *
     * @param blockIds - The block ids as an array of strings.
     *
     * @returns A promise which resolves in the block data.
     */
    async getBlocks(blockIds) {
        const jsonRpcRequestMethod = JsonRpcMethods_1.JSON_RPC_REQUEST_METHOD.GET_BLOCKS;
        if (this.clientConfig.retryStrategyOn) {
            return await (0, retryExecuteFunction_1.trySafeExecute)(this.sendJsonRPCRequest, [
                jsonRpcRequestMethod,
                [blockIds],
            ]);
        }
        else {
            return await this.sendJsonRPCRequest(jsonRpcRequestMethod, [blockIds]);
        }
    }
    /**
     * Show info about a list of endorsements.
     *
     * @param endorsementIds - The endorsement ids as an array of strings.
     *
     * @returns A promise which resolves in the endorsement data.
     */
    async getEndorsements(endorsementIds) {
        const jsonRpcRequestMethod = JsonRpcMethods_1.JSON_RPC_REQUEST_METHOD.GET_ENDORSEMENTS;
        if (this.clientConfig.retryStrategyOn) {
            return await (0, retryExecuteFunction_1.trySafeExecute)(this.sendJsonRPCRequest, [jsonRpcRequestMethod, [endorsementIds]]);
        }
        else {
            return await this.sendJsonRPCRequest(jsonRpcRequestMethod, [endorsementIds]);
        }
    }
    /**
     * Retrieves data about a list of operations.
     *
     * @param operationIds - An array of operation IDs to query.
     *
     * @returns A promise that resolves to an array of operation data.
     */
    async getOperations(operationIds) {
        const jsonRpcRequestMethod = JsonRpcMethods_1.JSON_RPC_REQUEST_METHOD.GET_OPERATIONS;
        if (this.clientConfig.retryStrategyOn) {
            return await (0, retryExecuteFunction_1.trySafeExecute)(this.sendJsonRPCRequest, [jsonRpcRequestMethod, [operationIds]]);
        }
        else {
            return await this.sendJsonRPCRequest(jsonRpcRequestMethod, [operationIds]);
        }
    }
    /**
     * Get cliques.
     *
     * @returns A promise which resolves to the cliques.
     */
    async getCliques() {
        const jsonRpcRequestMethod = JsonRpcMethods_1.JSON_RPC_REQUEST_METHOD.GET_CLIQUES;
        if (this.clientConfig.retryStrategyOn) {
            return await (0, retryExecuteFunction_1.trySafeExecute)(this.sendJsonRPCRequest, [
                jsonRpcRequestMethod,
                [],
            ]);
        }
        else {
            return await this.sendJsonRPCRequest(jsonRpcRequestMethod, []);
        }
    }
    /**
     * Retrieves a list of active stakers and their roll counts for the current cycle.
     *
     * @returns A promise that resolves to an array of staking addresses and their roll counts.
     */
    async getStakers() {
        const jsonRpcRequestMethod = JsonRpcMethods_1.JSON_RPC_REQUEST_METHOD.GET_STAKERS;
        if (this.clientConfig.retryStrategyOn) {
            return await (0, retryExecuteFunction_1.trySafeExecute)(this.sendJsonRPCRequest, [jsonRpcRequestMethod, []]);
        }
        else {
            return await this.sendJsonRPCRequest(jsonRpcRequestMethod, []);
        }
    }
    /**
     * Retrieves the data entries at both the latest final and active executed slots.
     *
     * @param addressesKeys - An array of objects containing address and key data.
     *
     * @returns A promise that resolves to an array of datastore entries.
     */
    async getDatastoreEntries(addressesKeys) {
        const data = [];
        for (const input of addressesKeys) {
            data.push({
                address: input.address,
                key: Array.prototype.slice.call(Buffer.from(input.key)),
            });
        }
        const jsonRpcRequestMethod = JsonRpcMethods_1.JSON_RPC_REQUEST_METHOD.GET_DATASTORE_ENTRIES;
        let datastoreEntries = [];
        if (this.clientConfig.retryStrategyOn) {
            datastoreEntries = await (0, retryExecuteFunction_1.trySafeExecute)(this.sendJsonRPCRequest, [jsonRpcRequestMethod, [data]]);
        }
        else {
            datastoreEntries = await this.sendJsonRPCRequest(jsonRpcRequestMethod, [data]);
        }
        return datastoreEntries.map((e) => {
            return {
                final_value: new Uint8Array(e.final_value),
                candidate_value: new Uint8Array(e.candidate_value),
            };
        });
    }
}
exports.PublicApiClient = PublicApiClient;
//# sourceMappingURL=PublicApiClient.js.map