"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SmartContractsClient = exports.PROTO_FILE_SEPARATOR = exports.MASSA_PROTOFILE_KEY = void 0;
/**
 * This file includes the implementation for the {@link SmartContractsClient} class. This class provides methods for interacting with smart contracts
 * in the Massa blockchain. Such methods include {@link SmartContractsClient#deploySmartContract|deploying}, {@link SmartContractsClient#callSmartContract|calling},
 * and {@link SmartContractsClient#readSmartContract|reading} smart contracts, as well as retrieving smart contract {@link SmartContractsClient#getFilteredScOutputEvents|events}
 * and {@link SmartContractsClient#getContractBalance|balances}.
 *
 * @module SmartContractsClient
 */
const EOperationStatus_1 = require("../interfaces/EOperationStatus");
const JsonRpcMethods_1 = require("../interfaces/JsonRpcMethods");
const converters_1 = require("../utils/converters");
const retryExecuteFunction_1 = require("../utils/retryExecuteFunction");
const time_1 = require("../utils/time");
const BaseClient_1 = require("./BaseClient");
const MAX_READ_BLOCK_GAS = BigInt(4294967295);
const TX_POLL_INTERVAL_MS = 10000;
const TX_STATUS_CHECK_RETRY_COUNT = 100;
/**
 * The key name (as a string) to look for when we are retrieving the proto file from a contract
 */
exports.MASSA_PROTOFILE_KEY = 'protoMassa';
/**
 * The separator used to split the proto file content into separate proto files
 */
exports.PROTO_FILE_SEPARATOR = '|||||';
/**
 * Smart Contracts Client object enables smart contract deployment, calls and streaming of events.
 */
class SmartContractsClient extends BaseClient_1.BaseClient {
    /**
     * Constructor for {@link SmartContractsClient} objects.
     */
    constructor(clientConfig, publicApiClient, walletClient) {
        super(clientConfig);
        this.publicApiClient = publicApiClient;
        this.walletClient = walletClient;
        // bind class methods
        this.deploySmartContract = this.deploySmartContract.bind(this);
        this.getFilteredScOutputEvents = this.getFilteredScOutputEvents.bind(this);
        this.executeReadOnlySmartContract =
            this.executeReadOnlySmartContract.bind(this);
        this.awaitRequiredOperationStatus =
            this.awaitRequiredOperationStatus.bind(this);
        this.getOperationStatus = this.getOperationStatus.bind(this);
        this.callSmartContract = this.callSmartContract.bind(this);
        this.readSmartContract = this.readSmartContract.bind(this);
        this.getContractBalance = this.getContractBalance.bind(this);
    }
    /**
     * Deploy a smart contract on th massa blockchain by creating and sending
     * an operation containing byte code.
     *
     * @remarks
     * If no executor is provided, the default wallet account from the provided {@link WalletClient}
     * will be used.
     *
     * @param contractData - The deployment contract data.
     * @param executor - The account to use for the deployment.
     *
     * @returns A promise that resolves to the operation ID of the deployment operation.
     */
    async deploySmartContract(contractData, executor) {
        const sender = executor || this.walletClient.getBaseAccount();
        if (!sender) {
            throw new Error(`No tx sender available`);
        }
        return await sender.deploySmartContract(contractData);
    }
    /**
     * Calls a smart contract method.
     *
     * @remarks
     * If no executor is provided, the default wallet account will be used.
     *
     * @param callData -  The data required for the smart contract call.
     * @param executor - The account that will execute the call (default: the default
     * wallet account from {@link WalletClient}).
     *
     * @returns A promise that resolves to the operation ID of the call operation as a string.
     */
    async callSmartContract(callData, executor) {
        const sender = executor || this.walletClient.getBaseAccount();
        if (!sender) {
            throw new Error(`No tx sender available`);
        }
        return await sender.callSmartContract(callData);
    }
    /**
     * Execute a dry run Smart contract call and returns some data regarding its execution
     * such as the changes of in the states that would have happen if the transaction was really executed on chain.
     *
     * @param readData - The data required for the a read operation of a smart contract.
     *
     * @returns A promise that resolves to an object which represents the result of the operation and contains data about its execution.
     */
    async readSmartContract(readData) {
        // check the max. allowed gas
        if (readData.maxGas > MAX_READ_BLOCK_GAS) {
            throw new Error(`The gas submitted ${readData.maxGas.toString()} exceeds the max. allowed block gas of ${MAX_READ_BLOCK_GAS.toString()}`);
        }
        // request data
        let baseAccountSignerAddress = null;
        if (this.walletClient.getBaseAccount()) {
            baseAccountSignerAddress = this.walletClient.getBaseAccount().address();
        }
        const data = {
            max_gas: Number(readData.maxGas),
            target_address: readData.targetAddress,
            target_function: readData.targetFunction,
            parameter: readData.parameter,
            caller_address: readData.callerAddress || baseAccountSignerAddress,
        };
        // returns operation ids
        const jsonRpcRequestMethod = JsonRpcMethods_1.JSON_RPC_REQUEST_METHOD.EXECUTE_READ_ONLY_CALL;
        let jsonRpcCallResult = [];
        if (this.clientConfig.retryStrategyOn) {
            jsonRpcCallResult = await (0, retryExecuteFunction_1.trySafeExecute)(this.sendJsonRPCRequest, [jsonRpcRequestMethod, [[data]]]);
        }
        else {
            jsonRpcCallResult = await this.sendJsonRPCRequest(jsonRpcRequestMethod, [
                [data],
            ]);
        }
        if (jsonRpcCallResult.length <= 0) {
            throw new Error(`Read operation bad response. No results array in json rpc response. Inspect smart contract`);
        }
        if (jsonRpcCallResult[0].result.Error) {
            throw new Error(jsonRpcCallResult[0].result.Error);
        }
        return {
            returnValue: new Uint8Array(jsonRpcCallResult[0].result.Ok),
            info: jsonRpcCallResult[0],
        };
    }
    /**
     * Returns the balance of the smart contract.
     *
     * @param address - The address of the smart contract.
     *
     * @returns A promise that resolves to the balance of the smart contract.
     */
    async getContractBalance(address) {
        const addresses = await this.publicApiClient.getAddresses([address]);
        if (addresses.length === 0)
            return null;
        const addressInfo = addresses.at(0);
        return {
            candidate: (0, converters_1.fromMAS)(addressInfo.candidate_balance),
            final: (0, converters_1.fromMAS)(addressInfo.final_balance),
        };
    }
    /**
     * Get filtered smart contract output events.
     *
     * @param eventFilterData - The filter data for the events.
     *
     * @returns A promise that resolves to an array of IEvent objects containing the filtered events.
     */
    async getFilteredScOutputEvents(eventFilterData) {
        const data = {
            start: eventFilterData.start,
            end: eventFilterData.end,
            emitter_address: eventFilterData.emitter_address,
            original_caller_address: eventFilterData.original_caller_address,
            original_operation_id: eventFilterData.original_operation_id,
            is_final: eventFilterData.is_final,
        };
        const jsonRpcRequestMethod = JsonRpcMethods_1.JSON_RPC_REQUEST_METHOD.GET_FILTERED_SC_OUTPUT_EVENT;
        // returns filtered events
        if (this.clientConfig.retryStrategyOn) {
            return await (0, retryExecuteFunction_1.trySafeExecute)(this.sendJsonRPCRequest, [
                jsonRpcRequestMethod,
                [data],
            ]);
        }
        else {
            return await this.sendJsonRPCRequest(jsonRpcRequestMethod, [data]);
        }
    }
    /**
     * Send a read-only smart contract execution request.
     *
     * @remarks
     * This method is used to dry-run a smart contract execution and get the changes of the states that would
     * have happen if the transaction was really executed on chain.
     * This operation does not modify the blockchain state.
     *
     * @param contractData - The data required for the operation.
     *
     * @returns A promise which resolves to an object containing data about the operation.
     *
     * @throws
     * - If the contract binary data is missing.
     * - If the contract contract address is missing.
     * - If the result is empty.
     * - If the result contains an error.
     */
    async executeReadOnlySmartContract(contractData) {
        if (!contractData.contractDataBinary) {
            throw new Error(`Expected non-null contract bytecode, but received null.`);
        }
        if (!contractData.address) {
            throw new Error(`Expected contract address, but received null.`);
        }
        const data = {
            max_gas: Number(contractData.maxGas),
            bytecode: Array.from(contractData.contractDataBinary),
            address: contractData.address,
        };
        let jsonRpcCallResult = [];
        const jsonRpcRequestMethod = JsonRpcMethods_1.JSON_RPC_REQUEST_METHOD.EXECUTE_READ_ONLY_BYTECODE;
        if (this.clientConfig.retryStrategyOn) {
            jsonRpcCallResult = await (0, retryExecuteFunction_1.trySafeExecute)(this.sendJsonRPCRequest, [jsonRpcRequestMethod, [[data]]]);
        }
        else {
            jsonRpcCallResult = await this.sendJsonRPCRequest(jsonRpcRequestMethod, [[data]]);
        }
        if (jsonRpcCallResult.length <= 0) {
            throw new Error(`Read operation bad response. No results array in json rpc response. Inspect smart contract`);
        }
        if (jsonRpcCallResult[0].result.Error) {
            throw new Error('Execute read-only smart contract error', {
                cause: jsonRpcCallResult[0].result.Error,
            });
        }
        return {
            returnValue: jsonRpcCallResult[0].result.Ok,
            info: jsonRpcCallResult[0],
        };
    }
    /**
     * Get the status of a specific operation.
     *
     * @param opId - The operation id.
     *
     * @returns A promise that resolves to the status of the operation.
     */
    async getOperationStatus(opId) {
        const operationData = await this.publicApiClient.getOperations([opId]);
        if (!operationData || operationData.length === 0)
            return EOperationStatus_1.EOperationStatus.NOT_FOUND;
        const opData = operationData[0];
        if (opData.is_operation_final) {
            return EOperationStatus_1.EOperationStatus.FINAL;
        }
        if (opData.in_blocks.length > 0) {
            return EOperationStatus_1.EOperationStatus.INCLUDED_PENDING;
        }
        if (opData.in_pool) {
            return EOperationStatus_1.EOperationStatus.AWAITING_INCLUSION;
        }
        return EOperationStatus_1.EOperationStatus.INCONSISTENT;
    }
    /**
     * Get the status of a specific operation and wait until it reaches the required status.
     *
     * @param opId - The required operation id.
     * @param requiredStatus - The required status.
     *
     * @returns A promise that resolves to the status of the operation.
     */
    async awaitRequiredOperationStatus(opId, requiredStatus) {
        let errCounter = 0;
        let pendingCounter = 0;
        while (true) {
            let status = EOperationStatus_1.EOperationStatus.NOT_FOUND;
            try {
                status = await this.getOperationStatus(opId);
            }
            catch (ex) {
                if (++errCounter > 100) {
                    const msg = `Failed to retrieve the tx status after 100 failed attempts for operation id: ${opId}.`;
                    console.error(msg, ex);
                    throw ex;
                }
                await (0, time_1.wait)(TX_POLL_INTERVAL_MS);
            }
            if (status == requiredStatus) {
                return status;
            }
            if (++pendingCounter > 1000) {
                const msg = `Getting the tx status for operation Id ${opId} took too long to conclude. We gave up after ${TX_POLL_INTERVAL_MS * TX_STATUS_CHECK_RETRY_COUNT}ms.`;
                console.warn(msg);
                throw new Error(msg);
            }
            await (0, time_1.wait)(TX_POLL_INTERVAL_MS);
        }
    }
}
exports.SmartContractsClient = SmartContractsClient;
//# sourceMappingURL=SmartContractsClient.js.map