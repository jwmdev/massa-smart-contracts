"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Web3Account = void 0;
const tslib_1 = require("tslib");
const Xbqcrypto_1 = require("../../utils/Xbqcrypto");
const keyAndAddresses_1 = require("../../utils/keyAndAddresses");
const ed = tslib_1.__importStar(require("@noble/ed25519"));
const BaseClient_1 = require("../BaseClient");
const OperationTypes_1 = require("../../interfaces/OperationTypes");
const bytes_1 = require("../../utils/bytes");
const JsonRpcMethods_1 = require("../../interfaces/JsonRpcMethods");
const retryExecuteFunction_1 = require("../../utils/retryExecuteFunction");
class Web3Account extends BaseClient_1.BaseClient {
    constructor(account, publicApiClient) {
        super(publicApiClient.clientConfig);
        this.account = account;
        this.publicApiClient = publicApiClient;
    }
    async verify() {
        // Create the secret key object
        const secretKeyBase58Encoded = this.account.secretKey;
        const secretKey = new keyAndAddresses_1.SecretKey(secretKeyBase58Encoded);
        // create the public key object
        const publicKey = await secretKey.getPublicKey();
        if (this.account.publicKey &&
            this.account.publicKey !== publicKey.base58Encode) {
            throw new Error('Public key does not correspond the the private key submitted');
        }
        // get wallet account address
        const address = new keyAndAddresses_1.Address(publicKey);
        if (this.account.address && this.account.address !== address.base58Encode) {
            throw new Error('Account address not correspond the the address submitted');
        }
    }
    async sign(data) {
        // check private keys to sign the message with.
        if (!this.account.secretKey) {
            throw new Error('No private key to sign the message with');
        }
        // check public key to verify the message with.
        if (!this.account.publicKey) {
            throw new Error('No public key to verify the signed message with');
        }
        // get private key
        const secretKey = new keyAndAddresses_1.SecretKey(this.account.secretKey);
        // bytes compaction
        const bytesCompact = Buffer.from(data);
        // Hash byte compact
        const messageHashDigest = (0, Xbqcrypto_1.hashBlake3)(bytesCompact);
        // sign the digest
        const sig = await secretKey.signDigest(messageHashDigest);
        // check sig length
        if (sig.length != 64) {
            throw new Error(`Invalid signature length. Expected 64, got ${sig.length}`);
        }
        // verify signature
        if (this.account.publicKey) {
            const publicKey = await secretKey.getPublicKey();
            const isVerified = await ed.verify(sig, messageHashDigest, publicKey.bytes);
            if (!isVerified) {
                throw new Error(`Signature could not be verified with public key. Please inspect`);
            }
        }
        // convert signature to base58
        const version = Buffer.from((0, Xbqcrypto_1.varintEncode)(secretKey.version));
        const base58Encoded = (0, Xbqcrypto_1.base58Encode)(Buffer.concat([version, sig]));
        return {
            base58Encoded,
        };
    }
    address() {
        return this.account.address;
    }
    async sellRolls(txData) {
        if (!this.account) {
            throw new Error(`No tx sender available`);
        }
        // get next period info
        const nodeStatusInfo = await this.publicApiClient.getNodeStatus();
        const expiryPeriod = nodeStatusInfo.next_slot.period + this.clientConfig.periodOffset;
        // bytes compaction
        const bytesCompact = this.compactBytesForOperation(txData, OperationTypes_1.OperationTypeId.RollSell, expiryPeriod);
        // sign payload
        const signature = await this.sign(Buffer.concat([(0, bytes_1.getBytesPublicKey)(this.account.publicKey), bytesCompact]));
        const data = {
            serialized_content: Array.prototype.slice.call(bytesCompact),
            creator_public_key: this.account.publicKey,
            signature: signature.base58Encoded,
        };
        // returns operation ids
        const opIds = await this.sendJsonRPCRequest(JsonRpcMethods_1.JSON_RPC_REQUEST_METHOD.SEND_OPERATIONS, [[data]]);
        return opIds[0];
    }
    async buyRolls(txData) {
        // get next period info
        const nodeStatusInfo = await this.publicApiClient.getNodeStatus();
        const expiryPeriod = nodeStatusInfo.next_slot.period + this.clientConfig.periodOffset;
        // bytes compaction
        const bytesCompact = this.compactBytesForOperation(txData, OperationTypes_1.OperationTypeId.RollBuy, expiryPeriod);
        // sign payload
        const signature = await this.sign(Buffer.concat([(0, bytes_1.getBytesPublicKey)(this.account.publicKey), bytesCompact]));
        const data = {
            serialized_content: Array.prototype.slice.call(bytesCompact),
            creator_public_key: this.account.publicKey,
            signature: signature.base58Encoded,
        };
        // returns operation ids
        const opIds = await this.sendJsonRPCRequest(JsonRpcMethods_1.JSON_RPC_REQUEST_METHOD.SEND_OPERATIONS, [[data]]);
        return opIds[0];
    }
    async sendTransaction(txData) {
        // get next period info
        const nodeStatusInfo = await this.publicApiClient.getNodeStatus();
        const expiryPeriod = nodeStatusInfo.next_slot.period + this.clientConfig.periodOffset;
        // bytes compaction
        const bytesCompact = this.compactBytesForOperation(txData, OperationTypes_1.OperationTypeId.Transaction, expiryPeriod);
        // sign payload
        const bytesPublicKey = (0, bytes_1.getBytesPublicKey)(this.account.publicKey);
        const signature = await this.sign(Buffer.concat([bytesPublicKey, bytesCompact]));
        // prepare tx data
        const data = {
            serialized_content: Array.prototype.slice.call(bytesCompact),
            creator_public_key: this.account.publicKey,
            signature: signature.base58Encoded,
        };
        // returns operation ids
        const opIds = await this.sendJsonRPCRequest(JsonRpcMethods_1.JSON_RPC_REQUEST_METHOD.SEND_OPERATIONS, [[data]]);
        return opIds[0];
    }
    async callSmartContract(callData) {
        // get next period info
        const nodeStatusInfo = await this.publicApiClient.getNodeStatus();
        const expiryPeriod = nodeStatusInfo.next_slot.period + this.clientConfig.periodOffset;
        // bytes compaction
        const bytesCompact = this.compactBytesForOperation(callData, OperationTypes_1.OperationTypeId.CallSC, expiryPeriod);
        // sign payload
        const bytesPublicKey = (0, bytes_1.getBytesPublicKey)(this.account.publicKey);
        const signature = await this.sign(Buffer.concat([bytesPublicKey, bytesCompact]));
        // request data
        const data = {
            serialized_content: Array.prototype.slice.call(bytesCompact),
            creator_public_key: this.account.publicKey,
            signature: signature.base58Encoded,
        };
        // returns operation ids
        let opIds = [];
        const jsonRpcRequestMethod = JsonRpcMethods_1.JSON_RPC_REQUEST_METHOD.SEND_OPERATIONS;
        if (this.clientConfig.retryStrategyOn) {
            opIds = await (0, retryExecuteFunction_1.trySafeExecute)(this.sendJsonRPCRequest, [
                jsonRpcRequestMethod,
                [[data]],
            ]);
        }
        else {
            opIds = await this.sendJsonRPCRequest(jsonRpcRequestMethod, [[data]]);
        }
        if (opIds.length <= 0) {
            throw new Error(`Call smart contract operation bad response. No results array in json rpc response. Inspect smart contract`);
        }
        return opIds[0];
    }
    async deploySmartContract(contractData) {
        // get next period info
        const nodeStatusInfo = await this.publicApiClient.getNodeStatus();
        const expiryPeriod = nodeStatusInfo.next_slot.period + this.clientConfig.periodOffset;
        // Check if SC data exists
        if (!contractData.contractDataBinary) {
            throw new Error(`Expected non-null contract bytecode, but received null.`);
        }
        // get the block size
        if (contractData.contractDataBinary.length >
            nodeStatusInfo.config.max_block_size / 2) {
            console.warn('bytecode size exceeded half of the maximum size of a block, operation will certainly be rejected');
        }
        // bytes compaction
        const bytesCompact = this.compactBytesForOperation(contractData, OperationTypes_1.OperationTypeId.ExecuteSC, expiryPeriod);
        // sign payload
        const bytesPublicKey = (0, bytes_1.getBytesPublicKey)(this.account.publicKey);
        const signature = await this.sign(Buffer.concat([bytesPublicKey, bytesCompact]));
        const data = {
            serialized_content: Array.prototype.slice.call(bytesCompact),
            creator_public_key: this.account.publicKey,
            signature: signature.base58Encoded,
        };
        // returns operation ids
        const opIds = await this.sendJsonRPCRequest(JsonRpcMethods_1.JSON_RPC_REQUEST_METHOD.SEND_OPERATIONS, [[data]]);
        if (opIds.length <= 0) {
            throw new Error(`Deploy smart contract operation bad response. No results array in json rpc response. Inspect smart contract`);
        }
        return opIds[0];
    }
}
exports.Web3Account = Web3Account;
//# sourceMappingURL=Web3Account.js.map