{"ast":null,"code":"import assert from './_assert.js';\nimport u64 from './_u64.js';\nimport { BLAKE2 } from './_blake2.js';\nimport { compress, IV } from './blake2s.js';\nimport { u8, u32, toBytes, wrapXOFConstructorWithOpts } from './utils.js';\n// Flag bitset\nvar Flags;\n(function (Flags) {\n  Flags[Flags[\"CHUNK_START\"] = 1] = \"CHUNK_START\";\n  Flags[Flags[\"CHUNK_END\"] = 2] = \"CHUNK_END\";\n  Flags[Flags[\"PARENT\"] = 4] = \"PARENT\";\n  Flags[Flags[\"ROOT\"] = 8] = \"ROOT\";\n  Flags[Flags[\"KEYED_HASH\"] = 16] = \"KEYED_HASH\";\n  Flags[Flags[\"DERIVE_KEY_CONTEXT\"] = 32] = \"DERIVE_KEY_CONTEXT\";\n  Flags[Flags[\"DERIVE_KEY_MATERIAL\"] = 64] = \"DERIVE_KEY_MATERIAL\";\n})(Flags || (Flags = {}));\nconst SIGMA = (() => {\n  const Id = Array.from({\n    length: 16\n  }, (_, i) => i);\n  const permute = arr => [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8].map(i => arr[i]);\n  const res = [];\n  for (let i = 0, v = Id; i < 7; i++, v = permute(v)) res.push(...v);\n  return Uint8Array.from(res);\n})();\n// Why is this so slow? It should be 6x faster than blake2b.\n// - There is only 30% reduction in number of rounds from blake2s\n// - This function uses tree mode to achive parallelisation via SIMD and threading,\n//   however in JS we don't have threads and SIMD, so we get only overhead from tree structure\n// - It is possible to speed it up via Web Workers, hovewer it will make code singnificantly more\n//   complicated, which we are trying to avoid, since this library is intended to be used\n//   for cryptographic purposes. Also, parallelization happens only on chunk level (1024 bytes),\n//   which won't really benefit small inputs.\nclass BLAKE3 extends BLAKE2 {\n  constructor(opts = {}, flags = 0) {\n    super(64, opts.dkLen === undefined ? 32 : opts.dkLen, {}, Number.MAX_SAFE_INTEGER, 0, 0);\n    this.flags = 0 | 0;\n    this.chunkPos = 0; // Position of current block in chunk\n    this.chunksDone = 0; // How many chunks we already have\n    this.stack = [];\n    // Output\n    this.posOut = 0;\n    this.bufferOut32 = new Uint32Array(16);\n    this.chunkOut = 0; // index of output chunk\n    this.enableXOF = true;\n    this.outputLen = opts.dkLen === undefined ? 32 : opts.dkLen;\n    assert.number(this.outputLen);\n    if (opts.key !== undefined && opts.context !== undefined) throw new Error('Blake3: only key or context can be specified at same time');else if (opts.key !== undefined) {\n      const key = toBytes(opts.key).slice();\n      if (key.length !== 32) throw new Error('Blake3: key should be 32 byte');\n      this.IV = u32(key);\n      this.flags = flags | Flags.KEYED_HASH;\n    } else if (opts.context !== undefined) {\n      const context_key = new BLAKE3({\n        dkLen: 32\n      }, Flags.DERIVE_KEY_CONTEXT).update(opts.context).digest();\n      this.IV = u32(context_key);\n      this.flags = flags | Flags.DERIVE_KEY_MATERIAL;\n    } else {\n      this.IV = IV.slice();\n      this.flags = flags;\n    }\n    this.state = this.IV.slice();\n    this.bufferOut = u8(this.bufferOut32);\n  }\n  // Unused\n  get() {\n    return [];\n  }\n  set() {}\n  b2Compress(counter, flags, buf, bufPos = 0) {\n    const {\n      state: s,\n      pos\n    } = this;\n    const {\n      h,\n      l\n    } = u64.fromBig(BigInt(counter), true);\n    // prettier-ignore\n    const {\n      v0,\n      v1,\n      v2,\n      v3,\n      v4,\n      v5,\n      v6,\n      v7,\n      v8,\n      v9,\n      v10,\n      v11,\n      v12,\n      v13,\n      v14,\n      v15\n    } = compress(SIGMA, bufPos, buf, 7, s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], IV[0], IV[1], IV[2], IV[3], h, l, pos, flags);\n    s[0] = v0 ^ v8;\n    s[1] = v1 ^ v9;\n    s[2] = v2 ^ v10;\n    s[3] = v3 ^ v11;\n    s[4] = v4 ^ v12;\n    s[5] = v5 ^ v13;\n    s[6] = v6 ^ v14;\n    s[7] = v7 ^ v15;\n  }\n  compress(buf, bufPos = 0, isLast = false) {\n    // Compress last block\n    let flags = this.flags;\n    if (!this.chunkPos) flags |= Flags.CHUNK_START;\n    if (this.chunkPos === 15 || isLast) flags |= Flags.CHUNK_END;\n    if (!isLast) this.pos = this.blockLen;\n    this.b2Compress(this.chunksDone, flags, buf, bufPos);\n    this.chunkPos += 1;\n    // If current block is last in chunk (16 blocks), then compress chunks\n    if (this.chunkPos === 16 || isLast) {\n      let chunk = this.state;\n      this.state = this.IV.slice();\n      // If not the last one, compress only when there are trailing zeros in chunk counter\n      // chunks used as binary tree where current stack is path. Zero means current leaf is finished and can be compressed.\n      // 1 (001) - leaf not finished (just push current chunk to stack)\n      // 2 (010) - leaf finished at depth=1 (merge with last elm on stack and push back)\n      // 3 (011) - last leaf not finished\n      // 4 (100) - leafs finished at depth=1 and depth=2\n      for (let last, chunks = this.chunksDone + 1; isLast || !(chunks & 1); chunks >>= 1) {\n        if (!(last = this.stack.pop())) break;\n        this.buffer32.set(last, 0);\n        this.buffer32.set(chunk, 8);\n        this.pos = this.blockLen;\n        this.b2Compress(0, this.flags | Flags.PARENT, this.buffer32, 0);\n        chunk = this.state;\n        this.state = this.IV.slice();\n      }\n      this.chunksDone++;\n      this.chunkPos = 0;\n      this.stack.push(chunk);\n    }\n    this.pos = 0;\n  }\n  _cloneInto(to) {\n    to = super._cloneInto(to);\n    const {\n      IV,\n      flags,\n      state,\n      chunkPos,\n      posOut,\n      chunkOut,\n      stack,\n      chunksDone\n    } = this;\n    to.state.set(state.slice());\n    to.stack = stack.map(i => Uint32Array.from(i));\n    to.IV.set(IV);\n    to.flags = flags;\n    to.chunkPos = chunkPos;\n    to.chunksDone = chunksDone;\n    to.posOut = posOut;\n    to.chunkOut = chunkOut;\n    to.enableXOF = this.enableXOF;\n    to.bufferOut32.set(this.bufferOut32);\n    return to;\n  }\n  destroy() {\n    this.destroyed = true;\n    this.state.fill(0);\n    this.buffer32.fill(0);\n    this.IV.fill(0);\n    this.bufferOut32.fill(0);\n    for (let i of this.stack) i.fill(0);\n  }\n  // Same as b2Compress, but doesn't modify state and returns 16 u32 array (instead of 8)\n  b2CompressOut() {\n    const {\n      state: s,\n      pos,\n      flags,\n      buffer32,\n      bufferOut32: out32\n    } = this;\n    const {\n      h,\n      l\n    } = u64.fromBig(BigInt(this.chunkOut++));\n    // prettier-ignore\n    const {\n      v0,\n      v1,\n      v2,\n      v3,\n      v4,\n      v5,\n      v6,\n      v7,\n      v8,\n      v9,\n      v10,\n      v11,\n      v12,\n      v13,\n      v14,\n      v15\n    } = compress(SIGMA, 0, buffer32, 7, s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], IV[0], IV[1], IV[2], IV[3], l, h, pos, flags);\n    out32[0] = v0 ^ v8;\n    out32[1] = v1 ^ v9;\n    out32[2] = v2 ^ v10;\n    out32[3] = v3 ^ v11;\n    out32[4] = v4 ^ v12;\n    out32[5] = v5 ^ v13;\n    out32[6] = v6 ^ v14;\n    out32[7] = v7 ^ v15;\n    out32[8] = s[0] ^ v8;\n    out32[9] = s[1] ^ v9;\n    out32[10] = s[2] ^ v10;\n    out32[11] = s[3] ^ v11;\n    out32[12] = s[4] ^ v12;\n    out32[13] = s[5] ^ v13;\n    out32[14] = s[6] ^ v14;\n    out32[15] = s[7] ^ v15;\n    this.posOut = 0;\n  }\n  finish() {\n    if (this.finished) return;\n    this.finished = true;\n    // Padding\n    this.buffer.fill(0, this.pos);\n    // Process last chunk\n    let flags = this.flags | Flags.ROOT;\n    if (this.stack.length) {\n      flags |= Flags.PARENT;\n      this.compress(this.buffer32, 0, true);\n      this.chunksDone = 0;\n      this.pos = this.blockLen;\n    } else {\n      flags |= (!this.chunkPos ? Flags.CHUNK_START : 0) | Flags.CHUNK_END;\n    }\n    this.flags = flags;\n    this.b2CompressOut();\n  }\n  writeInto(out) {\n    assert.exists(this, false);\n    assert.bytes(out);\n    this.finish();\n    const {\n      blockLen,\n      bufferOut\n    } = this;\n    for (let pos = 0, len = out.length; pos < len;) {\n      if (this.posOut >= blockLen) this.b2CompressOut();\n      const take = Math.min(blockLen - this.posOut, len - pos);\n      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n      this.posOut += take;\n      pos += take;\n    }\n    return out;\n  }\n  xofInto(out) {\n    if (!this.enableXOF) throw new Error('XOF is not possible after digest call');\n    return this.writeInto(out);\n  }\n  xof(bytes) {\n    assert.number(bytes);\n    return this.xofInto(new Uint8Array(bytes));\n  }\n  digestInto(out) {\n    assert.output(out, this);\n    if (this.finished) throw new Error('digest() was already called');\n    this.enableXOF = false;\n    this.writeInto(out);\n    this.destroy();\n    return out;\n  }\n  digest() {\n    return this.digestInto(new Uint8Array(this.outputLen));\n  }\n}\n/**\n * BLAKE3 hash function.\n * @param msg - message that would be hashed\n * @param opts - dkLen, key, context\n */\nexport const blake3 = wrapXOFConstructorWithOpts(opts => new BLAKE3(opts));","map":{"version":3,"names":["assert","u64","BLAKE2","compress","IV","u8","u32","toBytes","wrapXOFConstructorWithOpts","Flags","SIGMA","Id","Array","from","length","_","i","permute","arr","map","res","v","push","Uint8Array","BLAKE3","constructor","opts","flags","dkLen","undefined","Number","MAX_SAFE_INTEGER","chunkPos","chunksDone","stack","posOut","bufferOut32","Uint32Array","chunkOut","enableXOF","outputLen","number","key","context","Error","slice","KEYED_HASH","context_key","DERIVE_KEY_CONTEXT","update","digest","DERIVE_KEY_MATERIAL","state","bufferOut","get","set","b2Compress","counter","buf","bufPos","s","pos","h","l","fromBig","BigInt","v0","v1","v2","v3","v4","v5","v6","v7","v8","v9","v10","v11","v12","v13","v14","v15","isLast","CHUNK_START","CHUNK_END","blockLen","chunk","last","chunks","pop","buffer32","PARENT","_cloneInto","to","destroy","destroyed","fill","b2CompressOut","out32","finish","finished","buffer","ROOT","writeInto","out","exists","bytes","len","take","Math","min","subarray","xofInto","xof","digestInto","output","blake3"],"sources":["/Users/jwmdev/Development/github/massa/massa-sc-examples/age/react/node_modules/@noble/hashes/src/blake3.ts"],"sourcesContent":["import assert from './_assert.js';\nimport u64 from './_u64.js';\nimport { BLAKE2 } from './_blake2.js';\nimport { compress, IV } from './blake2s.js';\nimport { Input, u8, u32, toBytes, HashXOF, wrapXOFConstructorWithOpts } from './utils.js';\n\n// Flag bitset\nenum Flags {\n  CHUNK_START = 1 << 0,\n  CHUNK_END = 1 << 1,\n  PARENT = 1 << 2,\n  ROOT = 1 << 3,\n  KEYED_HASH = 1 << 4,\n  DERIVE_KEY_CONTEXT = 1 << 5,\n  DERIVE_KEY_MATERIAL = 1 << 6,\n}\n\nconst SIGMA: Uint8Array = (() => {\n  const Id = Array.from({ length: 16 }, (_, i) => i);\n  const permute = (arr: number[]) =>\n    [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8].map((i) => arr[i]);\n  const res: number[] = [];\n  for (let i = 0, v = Id; i < 7; i++, v = permute(v)) res.push(...v);\n  return Uint8Array.from(res);\n})();\n\n// - key: is 256-bit key\n// - context: string should be hardcoded, globally unique, and application - specific.\n//   A good default format for the context string is \"[application] [commit timestamp] [purpose]\"\n// - Only one of 'key' (keyed mode) or 'context' (derive key mode) can be used at same time\nexport type Blake3Opts = { dkLen?: number; key?: Input; context?: Input };\n\n// Why is this so slow? It should be 6x faster than blake2b.\n// - There is only 30% reduction in number of rounds from blake2s\n// - This function uses tree mode to achive parallelisation via SIMD and threading,\n//   however in JS we don't have threads and SIMD, so we get only overhead from tree structure\n// - It is possible to speed it up via Web Workers, hovewer it will make code singnificantly more\n//   complicated, which we are trying to avoid, since this library is intended to be used\n//   for cryptographic purposes. Also, parallelization happens only on chunk level (1024 bytes),\n//   which won't really benefit small inputs.\nclass BLAKE3 extends BLAKE2<BLAKE3> implements HashXOF<BLAKE3> {\n  private IV: Uint32Array;\n  private flags = 0 | 0;\n  private state: Uint32Array;\n  private chunkPos = 0; // Position of current block in chunk\n  private chunksDone = 0; // How many chunks we already have\n  private stack: Uint32Array[] = [];\n  // Output\n  private posOut = 0;\n  private bufferOut32 = new Uint32Array(16);\n  private bufferOut: Uint8Array;\n  private chunkOut = 0; // index of output chunk\n  private enableXOF = true;\n\n  constructor(opts: Blake3Opts = {}, flags = 0) {\n    super(64, opts.dkLen === undefined ? 32 : opts.dkLen, {}, Number.MAX_SAFE_INTEGER, 0, 0);\n    this.outputLen = opts.dkLen === undefined ? 32 : opts.dkLen;\n    assert.number(this.outputLen);\n    if (opts.key !== undefined && opts.context !== undefined)\n      throw new Error('Blake3: only key or context can be specified at same time');\n    else if (opts.key !== undefined) {\n      const key = toBytes(opts.key).slice();\n      if (key.length !== 32) throw new Error('Blake3: key should be 32 byte');\n      this.IV = u32(key);\n      this.flags = flags | Flags.KEYED_HASH;\n    } else if (opts.context !== undefined) {\n      const context_key = new BLAKE3({ dkLen: 32 }, Flags.DERIVE_KEY_CONTEXT)\n        .update(opts.context)\n        .digest();\n      this.IV = u32(context_key);\n      this.flags = flags | Flags.DERIVE_KEY_MATERIAL;\n    } else {\n      this.IV = IV.slice();\n      this.flags = flags;\n    }\n    this.state = this.IV.slice();\n    this.bufferOut = u8(this.bufferOut32);\n  }\n  // Unused\n  protected get() {\n    return [];\n  }\n  protected set() {}\n  private b2Compress(counter: number, flags: number, buf: Uint32Array, bufPos: number = 0) {\n    const { state: s, pos } = this;\n    const { h, l } = u64.fromBig(BigInt(counter), true);\n    // prettier-ignore\n    const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } =\n      compress(\n        SIGMA, bufPos, buf, 7,\n        s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7],\n        IV[0], IV[1], IV[2], IV[3], h, l, pos, flags\n      );\n    s[0] = v0 ^ v8;\n    s[1] = v1 ^ v9;\n    s[2] = v2 ^ v10;\n    s[3] = v3 ^ v11;\n    s[4] = v4 ^ v12;\n    s[5] = v5 ^ v13;\n    s[6] = v6 ^ v14;\n    s[7] = v7 ^ v15;\n  }\n  protected compress(buf: Uint32Array, bufPos: number = 0, isLast: boolean = false) {\n    // Compress last block\n    let flags = this.flags;\n    if (!this.chunkPos) flags |= Flags.CHUNK_START;\n    if (this.chunkPos === 15 || isLast) flags |= Flags.CHUNK_END;\n    if (!isLast) this.pos = this.blockLen;\n    this.b2Compress(this.chunksDone, flags, buf, bufPos);\n    this.chunkPos += 1;\n    // If current block is last in chunk (16 blocks), then compress chunks\n    if (this.chunkPos === 16 || isLast) {\n      let chunk = this.state;\n      this.state = this.IV.slice();\n      // If not the last one, compress only when there are trailing zeros in chunk counter\n      // chunks used as binary tree where current stack is path. Zero means current leaf is finished and can be compressed.\n      // 1 (001) - leaf not finished (just push current chunk to stack)\n      // 2 (010) - leaf finished at depth=1 (merge with last elm on stack and push back)\n      // 3 (011) - last leaf not finished\n      // 4 (100) - leafs finished at depth=1 and depth=2\n      for (let last, chunks = this.chunksDone + 1; isLast || !(chunks & 1); chunks >>= 1) {\n        if (!(last = this.stack.pop())) break;\n        this.buffer32.set(last, 0);\n        this.buffer32.set(chunk, 8);\n        this.pos = this.blockLen;\n        this.b2Compress(0, this.flags | Flags.PARENT, this.buffer32, 0);\n        chunk = this.state;\n        this.state = this.IV.slice();\n      }\n      this.chunksDone++;\n      this.chunkPos = 0;\n      this.stack.push(chunk);\n    }\n    this.pos = 0;\n  }\n  _cloneInto(to?: BLAKE3): BLAKE3 {\n    to = super._cloneInto(to) as BLAKE3;\n    const { IV, flags, state, chunkPos, posOut, chunkOut, stack, chunksDone } = this;\n    to.state.set(state.slice());\n    to.stack = stack.map((i) => Uint32Array.from(i));\n    to.IV.set(IV);\n    to.flags = flags;\n    to.chunkPos = chunkPos;\n    to.chunksDone = chunksDone;\n    to.posOut = posOut;\n    to.chunkOut = chunkOut;\n    to.enableXOF = this.enableXOF;\n    to.bufferOut32.set(this.bufferOut32);\n    return to;\n  }\n  destroy() {\n    this.destroyed = true;\n    this.state.fill(0);\n    this.buffer32.fill(0);\n    this.IV.fill(0);\n    this.bufferOut32.fill(0);\n    for (let i of this.stack) i.fill(0);\n  }\n  // Same as b2Compress, but doesn't modify state and returns 16 u32 array (instead of 8)\n  private b2CompressOut() {\n    const { state: s, pos, flags, buffer32, bufferOut32: out32 } = this;\n    const { h, l } = u64.fromBig(BigInt(this.chunkOut++));\n    // prettier-ignore\n    const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } =\n      compress(\n        SIGMA, 0, buffer32, 7,\n        s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7],\n        IV[0], IV[1], IV[2], IV[3], l, h, pos, flags\n      );\n    out32[0] = v0 ^ v8;\n    out32[1] = v1 ^ v9;\n    out32[2] = v2 ^ v10;\n    out32[3] = v3 ^ v11;\n    out32[4] = v4 ^ v12;\n    out32[5] = v5 ^ v13;\n    out32[6] = v6 ^ v14;\n    out32[7] = v7 ^ v15;\n    out32[8] = s[0] ^ v8;\n    out32[9] = s[1] ^ v9;\n    out32[10] = s[2] ^ v10;\n    out32[11] = s[3] ^ v11;\n    out32[12] = s[4] ^ v12;\n    out32[13] = s[5] ^ v13;\n    out32[14] = s[6] ^ v14;\n    out32[15] = s[7] ^ v15;\n    this.posOut = 0;\n  }\n  protected finish() {\n    if (this.finished) return;\n    this.finished = true;\n    // Padding\n    this.buffer.fill(0, this.pos);\n    // Process last chunk\n    let flags = this.flags | Flags.ROOT;\n    if (this.stack.length) {\n      flags |= Flags.PARENT;\n      this.compress(this.buffer32, 0, true);\n      this.chunksDone = 0;\n      this.pos = this.blockLen;\n    } else {\n      flags |= (!this.chunkPos ? Flags.CHUNK_START : 0) | Flags.CHUNK_END;\n    }\n    this.flags = flags;\n    this.b2CompressOut();\n  }\n  private writeInto(out: Uint8Array) {\n    assert.exists(this, false);\n    assert.bytes(out);\n    this.finish();\n    const { blockLen, bufferOut } = this;\n    for (let pos = 0, len = out.length; pos < len; ) {\n      if (this.posOut >= blockLen) this.b2CompressOut();\n      const take = Math.min(blockLen - this.posOut, len - pos);\n      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n      this.posOut += take;\n      pos += take;\n    }\n    return out;\n  }\n  xofInto(out: Uint8Array): Uint8Array {\n    if (!this.enableXOF) throw new Error('XOF is not possible after digest call');\n    return this.writeInto(out);\n  }\n  xof(bytes: number): Uint8Array {\n    assert.number(bytes);\n    return this.xofInto(new Uint8Array(bytes));\n  }\n  digestInto(out: Uint8Array) {\n    assert.output(out, this);\n    if (this.finished) throw new Error('digest() was already called');\n    this.enableXOF = false;\n    this.writeInto(out);\n    this.destroy();\n    return out;\n  }\n  digest() {\n    return this.digestInto(new Uint8Array(this.outputLen));\n  }\n}\n\n/**\n * BLAKE3 hash function.\n * @param msg - message that would be hashed\n * @param opts - dkLen, key, context\n */\nexport const blake3 = wrapXOFConstructorWithOpts<BLAKE3, Blake3Opts>((opts) => new BLAKE3(opts));\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}