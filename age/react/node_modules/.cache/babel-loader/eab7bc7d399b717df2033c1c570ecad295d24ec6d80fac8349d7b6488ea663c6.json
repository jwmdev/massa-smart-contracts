{"ast":null,"code":"import { base58Encode, varintEncode, varintDecode, hashBlake3 } from './Xbqcrypto';\nimport * as ed from '@noble/ed25519';\nimport { getBytesPublicKey, getBytesSecretKey } from './bytes';\n/**\n * Prefixes for secret keys, public keys, and addresses.\n * Prefixes are used as a convention to differentiate one key from another.\n */\nconst PUBLIC_KEY_PREFIX = 'P';\nconst ADDRESS_PREFIX = 'AU';\n/**\n * A secret key.\n * The secret key object is created from a base58 encoded string representing the secret key.\n *\n * @remarks\n * - String representation is S + base58Check(version_bytes + secret_key_hash_bytes)\n * - bytes attribute is the Uint8Array representation of the secret key.\n */\nexport class SecretKey {\n  version;\n  bytes;\n  constructor(secretKeyBase58Encoded) {\n    const versionAndKeyBytes = getBytesSecretKey(secretKeyBase58Encoded);\n    // Slice off the version byte\n    this.bytes = versionAndKeyBytes.slice(1);\n    this.version = varintDecode(versionAndKeyBytes.slice(0, 1)).value;\n  }\n  /* Get the public key from the secret key */\n  async getPublicKey() {\n    const publicKeyArray = await ed.getPublicKey(this.bytes);\n    return new PublicKey(publicKeyArray, this.version);\n  }\n  /* Sign a message hash digest with the secret key */\n  async signDigest(messageHashDigest) {\n    return await ed.sign(messageHashDigest, this.bytes);\n  }\n}\n/**\n * The PublicKey class represents a cryptographic public key.\n *\n * @remarks\n * - The public key is derived from the secret key and got the same version as the secret key.\n * - String representation is P + base58Check(version_bytes + public_key_hash_bytes)\n * - bytes attribute is the Uint8Array representation of the public key.\n */\nexport class PublicKey {\n  version;\n  base58Encode;\n  bytes;\n  constructor(bytes, version) {\n    this.version = version;\n    this.bytes = bytes;\n    const versionBuffer = Buffer.from(varintEncode(this.version));\n    // Generate base58 encoded public key\n    this.base58Encode = PUBLIC_KEY_PREFIX + base58Encode(Buffer.concat([versionBuffer, Buffer.from(this.bytes)]));\n  }\n  // Create a new PublicKey object from a base58 encoded string\n  static fromString(base58Encoded) {\n    const versionAndKeyBytes = getBytesPublicKey(base58Encoded);\n    // Slice off the version byte\n    const version = varintDecode(versionAndKeyBytes.slice(0, 1)).value;\n    const keyBytes = versionAndKeyBytes.slice(1);\n    return new PublicKey(keyBytes, version);\n  }\n}\n/**\n * An address.\n *\n * @remarks the address object is created from a public key and got the same version as the public key.\n *\n * @remarks\n * - String representation is A + U/S + base58Check(version_bytes + hashBlake3(version_bytes + public_key_bytes))\n * - The address bytes representation is `version + hashBlake3(version + publicKey)`.\n * - bytes is not an attribute of the address object because it is not needed.\n */\nexport class Address {\n  version;\n  base58Encode;\n  constructor(publicKey) {\n    this.version = publicKey.version;\n    const versionBuffer = Buffer.from(varintEncode(this.version));\n    const versionAndPublicKey = Buffer.concat([versionBuffer, publicKey.bytes]);\n    // Generate base58 encoded address\n    this.base58Encode = ADDRESS_PREFIX + base58Encode(Buffer.concat([versionBuffer, hashBlake3(versionAndPublicKey)]));\n  }\n}","map":{"version":3,"names":["base58Encode","varintEncode","varintDecode","hashBlake3","ed","getBytesPublicKey","getBytesSecretKey","PUBLIC_KEY_PREFIX","ADDRESS_PREFIX","SecretKey","version","bytes","constructor","secretKeyBase58Encoded","versionAndKeyBytes","slice","value","getPublicKey","publicKeyArray","PublicKey","signDigest","messageHashDigest","sign","versionBuffer","Buffer","from","concat","fromString","base58Encoded","keyBytes","Address","publicKey","versionAndPublicKey"],"sources":["../../../src/utils/keyAndAddresses.ts"],"sourcesContent":[null],"mappings":"AAAA,SACEA,YAAY,EACZC,YAAY,EACZC,YAAY,EACZC,UAAU,QACL,aAAa;AAEpB,OAAO,KAAKC,EAAE,MAAM,gBAAgB;AACpC,SAASC,iBAAiB,EAAEC,iBAAiB,QAAQ,SAAS;AAE9D;;;;AAIA,MAAMC,iBAAiB,GAAG,GAAG;AAC7B,MAAMC,cAAc,GAAG,IAAI;AAE3B;;;;;;;;AAQA,OAAM,MAAOC,SAAS;EACpBC,OAAO;EACCC,KAAK;EAEbC,YAAYC,sBAA8B;IACxC,MAAMC,kBAAkB,GAAGR,iBAAiB,CAACO,sBAAsB,CAAC;IAEpE;IACA,IAAI,CAACF,KAAK,GAAGG,kBAAkB,CAACC,KAAK,CAAC,CAAC,CAAC;IAExC,IAAI,CAACL,OAAO,GAAGR,YAAY,CAACY,kBAAkB,CAACC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAACC,KAAK;EACnE;EAEA;EACA,MAAMC,YAAYA,CAAA;IAChB,MAAMC,cAAc,GAAe,MAAMd,EAAE,CAACa,YAAY,CAAC,IAAI,CAACN,KAAK,CAAC;IACpE,OAAO,IAAIQ,SAAS,CAACD,cAAc,EAAE,IAAI,CAACR,OAAO,CAAC;EACpD;EAEA;EACA,MAAMU,UAAUA,CAACC,iBAA6B;IAC5C,OAAO,MAAMjB,EAAE,CAACkB,IAAI,CAACD,iBAAiB,EAAE,IAAI,CAACV,KAAK,CAAC;EACrD;;AAGF;;;;;;;;AAQA,OAAM,MAAOQ,SAAS;EACpBT,OAAO;EACPV,YAAY;EACZW,KAAK;EAELC,YAAYD,KAAiB,EAAED,OAAe;IAC5C,IAAI,CAACA,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,KAAK,GAAGA,KAAK;IAClB,MAAMY,aAAa,GAAGC,MAAM,CAACC,IAAI,CAACxB,YAAY,CAAC,IAAI,CAACS,OAAO,CAAC,CAAC;IAE7D;IACA,IAAI,CAACV,YAAY,GACfO,iBAAiB,GACjBP,YAAY,CAACwB,MAAM,CAACE,MAAM,CAAC,CAACH,aAAa,EAAEC,MAAM,CAACC,IAAI,CAAC,IAAI,CAACd,KAAK,CAAC,CAAC,CAAC,CAAC;EACzE;EAEA;EACA,OAAOgB,UAAUA,CAACC,aAAqB;IACrC,MAAMd,kBAAkB,GAAGT,iBAAiB,CAACuB,aAAa,CAAC;IAE3D;IACA,MAAMlB,OAAO,GAAGR,YAAY,CAACY,kBAAkB,CAACC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAACC,KAAK;IAClE,MAAMa,QAAQ,GAAGf,kBAAkB,CAACC,KAAK,CAAC,CAAC,CAAC;IAE5C,OAAO,IAAII,SAAS,CAACU,QAAQ,EAAEnB,OAAO,CAAC;EACzC;;AAGF;;;;;;;;;;AAUA,OAAM,MAAOoB,OAAO;EAClBpB,OAAO;EACPV,YAAY;EAEZY,YAAYmB,SAAoB;IAC9B,IAAI,CAACrB,OAAO,GAAGqB,SAAS,CAACrB,OAAO;IAEhC,MAAMa,aAAa,GAAGC,MAAM,CAACC,IAAI,CAACxB,YAAY,CAAC,IAAI,CAACS,OAAO,CAAC,CAAC;IAC7D,MAAMsB,mBAAmB,GAAGR,MAAM,CAACE,MAAM,CAAC,CAACH,aAAa,EAAEQ,SAAS,CAACpB,KAAK,CAAC,CAAC;IAE3E;IACA,IAAI,CAACX,YAAY,GACfQ,cAAc,GACdR,YAAY,CACVwB,MAAM,CAACE,MAAM,CAAC,CAACH,aAAa,EAAEpB,UAAU,CAAC6B,mBAAmB,CAAC,CAAC,CAAC,CAChE;EACL"},"metadata":{},"sourceType":"module","externalDependencies":[]}