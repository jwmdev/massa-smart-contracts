{"ast":null,"code":"/* eslint-disable no-case-declarations */\nimport { Args, ArrayType } from '../arguments';\nimport { bytesToStr } from './strings';\nimport { byteToBool } from './bool';\nimport { byteToU8, bytesToF32, bytesToF64, bytesToI32, bytesToI64, bytesToU128, bytesToU256, bytesToU32, bytesToU64 } from './numbers';\n/**\n * Get the byte size of a typed array unit.\n *\n * @param typedArrayType - The typed array unit to get the size of.\n *\n * @returns The size of the typed array unit.\n */\nexport const getDatatypeSize = type => {\n  switch (type) {\n    case ArrayType.BOOL:\n    case ArrayType.U8:\n      return 1;\n    case ArrayType.F32:\n    case ArrayType.I32:\n    case ArrayType.U32:\n      return 4;\n    case ArrayType.F64:\n    case ArrayType.I64:\n    case ArrayType.U64:\n      return 8;\n    case ArrayType.U128:\n      return 16;\n    case ArrayType.U256:\n      return 32;\n    default:\n      throw new Error(`Unsupported type: ${Object.keys(ArrayType)[type]}`);\n  }\n};\n/**\n * Serializes an array of serializable objects to bytes.\n *\n * @param source - The array of serializable objects to serialize.\n *\n * @returns The serialized array as Uint8Array.\n */\nexport function serializableObjectsArrayToBytes(source) {\n  const nbElements = source.length;\n  const pointers = new Array(nbElements);\n  const sizes = new Array(nbElements);\n  let totalLength = 0;\n  for (let i = 0; i < nbElements; i++) {\n    const bytes = source[i].serialize();\n    pointers[i] = bytes;\n    sizes[i] = bytes.length;\n    totalLength += bytes.length;\n  }\n  const target = new Uint8Array(totalLength);\n  let offset = 0;\n  for (let i = 0; i < nbElements; i++) {\n    target.set(pointers[i], offset);\n    offset += sizes[i];\n  }\n  return target;\n}\n/**\n * Deserializes a bytes array into an array of deserialized objects.\n *\n * @param data - The bytes array to deserialize.\n * @param offset - The offset to start deserializing from.\n * @param Clazz - The class used for deserialization.\n *\n * @returns The deserialized array of objects.\n */\nexport function deserializeObj(data, offset, Clazz) {\n  const deserialized = new Clazz().deserialize(data, offset);\n  return deserialized;\n}\n/**\n * Converts a Uint8Array into an array of deserialized type parameters.\n *\n * @param source - The Uint8Array to convert.\n * @param Clazz - The class constructor for deserialization.\n *\n * @returns An array of deserialized objects.\n */\nexport function bytesToSerializableObjectArray(source, Clazz) {\n  const array = [];\n  let offset = 0;\n  while (offset < source.length) {\n    let deserializationResult = deserializeObj(source, offset, Clazz);\n    offset = deserializationResult.offset;\n    array.push(deserializationResult.instance);\n  }\n  return array;\n}\n/**\n * Convert an array of native types to a Uint8Array.\n *\n * @remarks\n * This function performs a deep copy for native types only.\n * It is inspired by https://github.com/AssemblyScript/assemblyscript/blob/main/std/assembly/array.ts#L69-L81\n *\n * @param source - The array to convert.\n * @param type - The typed array unit type.\n *\n * @returns The converted Uint8Array.\n */\nexport function arrayToBytes(source, type) {\n  let args = new Args();\n  source.forEach(value => {\n    switch (type) {\n      case ArrayType.STRING:\n        args.addString(value);\n        break;\n      case ArrayType.BOOL:\n        args.addBool(value);\n        break;\n      case ArrayType.U8:\n        args.addU8(value);\n        break;\n      case ArrayType.F64:\n        args.addF64(value);\n        break;\n      case ArrayType.F32:\n        args.addF32(value);\n        break;\n      case ArrayType.I32:\n        args.addI32(value);\n        break;\n      case ArrayType.I64:\n        args.addI64(value);\n        break;\n      case ArrayType.U32:\n        args.addU32(value);\n        break;\n      case ArrayType.U64:\n        args.addU64(value);\n        break;\n      case ArrayType.U128:\n        args.addU128(value);\n        break;\n      case ArrayType.U256:\n        args.addU256(value);\n        break;\n      default:\n        throw new Error(`Unsupported type: ${type}`);\n    }\n  });\n  return new Uint8Array(args.serialize());\n}\n/**\n * Converts a Uint8Array into an array of native types.\n *\n * @remarks\n * This function is inspired by https://github.com/AssemblyScript/assemblyscript/blob/main/std/assembly/array.ts#L69-L81\n *\n * @param source - The Uint8Array to convert.\n * @param type - The typed array unit type.\n *\n * @returns An array of converted native types.\n */\nexport function bytesToArray(source, type) {\n  const sourceLength = source.length;\n  let byteOffset = 0;\n  const result = [];\n  let eltSize;\n  if (type !== ArrayType.STRING) {\n    eltSize = getDatatypeSize(type);\n  }\n  while (byteOffset < sourceLength) {\n    if (type === ArrayType.STRING) {\n      eltSize = bytesToU32(source, byteOffset);\n      byteOffset += 4;\n    }\n    const elt = source.slice(byteOffset, byteOffset + eltSize);\n    byteOffset += eltSize;\n    switch (type) {\n      case ArrayType.STRING:\n        result.push(bytesToStr(elt));\n        break;\n      case ArrayType.BOOL:\n        result.push(byteToBool(elt));\n        break;\n      case ArrayType.U8:\n        result.push(byteToU8(elt));\n        break;\n      case ArrayType.F32:\n        result.push(bytesToF32(elt));\n        break;\n      case ArrayType.F64:\n        result.push(bytesToF64(elt));\n        break;\n      case ArrayType.I32:\n        result.push(bytesToI32(elt));\n        break;\n      case ArrayType.I64:\n        result.push(bytesToI64(elt));\n        break;\n      case ArrayType.U32:\n        result.push(bytesToU32(elt));\n        break;\n      case ArrayType.U64:\n        result.push(bytesToU64(elt));\n        break;\n      case ArrayType.U128:\n        result.push(bytesToU128(elt));\n        break;\n      case ArrayType.U256:\n        result.push(bytesToU256(elt));\n        break;\n    }\n  }\n  return result;\n}","map":{"version":3,"names":["Args","ArrayType","bytesToStr","byteToBool","byteToU8","bytesToF32","bytesToF64","bytesToI32","bytesToI64","bytesToU128","bytesToU256","bytesToU32","bytesToU64","getDatatypeSize","type","BOOL","U8","F32","I32","U32","F64","I64","U64","U128","U256","Error","Object","keys","serializableObjectsArrayToBytes","source","nbElements","length","pointers","Array","sizes","totalLength","i","bytes","serialize","target","Uint8Array","offset","set","deserializeObj","data","Clazz","deserialized","deserialize","bytesToSerializableObjectArray","array","deserializationResult","push","instance","arrayToBytes","args","forEach","value","STRING","addString","addBool","addU8","addF64","addF32","addI32","addI64","addU32","addU64","addU128","addU256","bytesToArray","sourceLength","byteOffset","result","eltSize","elt","slice"],"sources":["/Users/jwmdev/Development/github/massa/massa-sc-examples/age/react/node_modules/@massalabs/web3-utils/src/serializers/arrays.ts"],"sourcesContent":["/* eslint-disable no-case-declarations */\n\nimport { Args, NativeType, ArrayType } from '../arguments';\nimport {\n  IDeserializedResult,\n  ISerializable,\n} from '../ISerializable';\nimport { bytesToStr } from './strings';\nimport { byteToBool } from './bool';\nimport {\n  byteToU8,\n  bytesToF32,\n  bytesToF64,\n  bytesToI32,\n  bytesToI64,\n  bytesToU128,\n  bytesToU256,\n  bytesToU32,\n  bytesToU64,\n} from './numbers';\n\n/**\n * Get the byte size of a typed array unit.\n *\n * @param typedArrayType - The typed array unit to get the size of.\n *\n * @returns The size of the typed array unit.\n */\nexport const getDatatypeSize = (type: ArrayType): number => {\n  switch (type) {\n    case ArrayType.BOOL:\n    case ArrayType.U8:\n      return 1;\n    case ArrayType.F32:\n    case ArrayType.I32:\n    case ArrayType.U32:\n      return 4;\n    case ArrayType.F64:\n    case ArrayType.I64:\n    case ArrayType.U64:\n      return 8;\n    case ArrayType.U128:\n      return 16;\n    case ArrayType.U256:\n      return 32;\n    default:\n      throw new Error(`Unsupported type: ${Object.keys(ArrayType)[type]}`);\n  }\n};\n\n/**\n * Serializes an array of serializable objects to bytes.\n *\n * @param source - The array of serializable objects to serialize.\n *\n * @returns The serialized array as Uint8Array.\n */\nexport function serializableObjectsArrayToBytes<T extends ISerializable<T>>(\n  source: T[],\n): Uint8Array {\n  const nbElements = source.length;\n  const pointers = new Array<Uint8Array>(nbElements);\n  const sizes = new Array<number>(nbElements);\n  let totalLength = 0;\n\n  for (let i = 0; i < nbElements; i++) {\n    const bytes: Uint8Array = source[i].serialize();\n    pointers[i] = bytes;\n    sizes[i] = bytes.length;\n    totalLength += bytes.length;\n  }\n\n  const target = new Uint8Array(totalLength);\n\n  let offset = 0;\n  for (let i = 0; i < nbElements; i++) {\n    target.set(pointers[i], offset);\n    offset += sizes[i];\n  }\n\n  return target;\n}\n\n/**\n * Deserializes a bytes array into an array of deserialized objects.\n *\n * @param data - The bytes array to deserialize.\n * @param offset - The offset to start deserializing from.\n * @param Clazz - The class used for deserialization.\n *\n * @returns The deserialized array of objects.\n */\nexport function deserializeObj<T extends ISerializable<T>>(\n  data: Uint8Array,\n  offset: number,\n  Clazz: new () => T,\n): IDeserializedResult<T> {\n  const deserialized = new Clazz().deserialize(data, offset);\n  return deserialized;\n}\n\n/**\n * Converts a Uint8Array into an array of deserialized type parameters.\n *\n * @param source - The Uint8Array to convert.\n * @param Clazz - The class constructor for deserialization.\n *\n * @returns An array of deserialized objects.\n */\nexport function bytesToSerializableObjectArray<T extends ISerializable<T>>(\n  source: Uint8Array,\n  Clazz: new () => T,\n): T[] {\n  const array: T[] = [];\n  let offset = 0;\n\n  while (offset < source.length) {\n    let deserializationResult = deserializeObj(source, offset, Clazz);\n    offset = deserializationResult.offset;\n    array.push(deserializationResult.instance);\n  }\n\n  return array;\n}\n\n/**\n * Convert an array of native types to a Uint8Array.\n *\n * @remarks\n * This function performs a deep copy for native types only.\n * It is inspired by https://github.com/AssemblyScript/assemblyscript/blob/main/std/assembly/array.ts#L69-L81\n *\n * @param source - The array to convert.\n * @param type - The typed array unit type.\n *\n * @returns The converted Uint8Array.\n */\nexport function arrayToBytes(\n  source: NativeType[],\n  type: ArrayType,\n): Uint8Array {\n  let args = new Args();\n  source.forEach((value) => {\n    switch (type) {\n      case ArrayType.STRING:\n        args.addString(value as string);\n        break;\n      case ArrayType.BOOL:\n        args.addBool(value as boolean);\n        break;\n      case ArrayType.U8:\n        args.addU8(value as number);\n        break;\n      case ArrayType.F64:\n        args.addF64(value as number);\n        break;\n      case ArrayType.F32:\n        args.addF32(value as number);\n        break;\n      case ArrayType.I32:\n        args.addI32(value as number);\n        break;\n      case ArrayType.I64:\n        args.addI64(value as bigint);\n        break;\n      case ArrayType.U32:\n        args.addU32(value as number);\n        break;\n      case ArrayType.U64:\n        args.addU64(value as bigint);\n        break;\n      case ArrayType.U128:\n        args.addU128(value as bigint);\n        break;\n      case ArrayType.U256:\n        args.addU256(value as bigint);\n        break;\n      default:\n        throw new Error(`Unsupported type: ${type}`);\n    }\n  });\n  return new Uint8Array(args.serialize());\n}\n\n/**\n * Converts a Uint8Array into an array of native types.\n *\n * @remarks\n * This function is inspired by https://github.com/AssemblyScript/assemblyscript/blob/main/std/assembly/array.ts#L69-L81\n *\n * @param source - The Uint8Array to convert.\n * @param type - The typed array unit type.\n *\n * @returns An array of converted native types.\n */\nexport function bytesToArray<T>(source: Uint8Array, type: ArrayType): T[] {\n  const sourceLength = source.length;\n\n  let byteOffset = 0;\n  const result: T[] = [];\n  let eltSize: number;\n\n  if (type !== ArrayType.STRING) {\n    eltSize = getDatatypeSize(type);\n  }\n\n  while (byteOffset < sourceLength) {\n    if (type === ArrayType.STRING) {\n      eltSize = bytesToU32(source, byteOffset);\n      byteOffset += 4;\n    }\n    const elt = source.slice(byteOffset, byteOffset + eltSize);\n    byteOffset += eltSize;\n\n    switch (type) {\n      case ArrayType.STRING:\n        result.push(bytesToStr(elt) as T);\n        break;\n      case ArrayType.BOOL:\n        result.push(byteToBool(elt) as T);\n        break;\n      case ArrayType.U8:\n        result.push(byteToU8(elt) as T);\n        break;\n      case ArrayType.F32:\n        result.push(bytesToF32(elt) as T);\n        break;\n      case ArrayType.F64:\n        result.push(bytesToF64(elt) as T);\n        break;\n      case ArrayType.I32:\n        result.push(bytesToI32(elt) as T);\n        break;\n      case ArrayType.I64:\n        result.push(bytesToI64(elt) as T);\n        break;\n      case ArrayType.U32:\n        result.push(bytesToU32(elt) as T);\n        break;\n      case ArrayType.U64:\n        result.push(bytesToU64(elt) as T);\n        break;\n      case ArrayType.U128:\n        result.push(bytesToU128(elt) as T);\n        break;\n      case ArrayType.U256:\n        result.push(bytesToU256(elt) as T);\n        break;\n    }\n  }\n  return result;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}